// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_msg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsPointCloudImpl();
void InitDefaultsPointCloud();
void InitDefaultsFreespaceImpl();
void InitDefaultsFreespace();
void InitDefaultsTrailerImpl();
void InitDefaultsTrailer();
void InitDefaultsBridgeImpl();
void InitDefaultsBridge();
void InitDefaultsBoundaryImpl();
void InitDefaultsBoundary();
void InitDefaultsContainerImpl();
void InitDefaultsContainer();
void InitDefaultsSignboardImpl();
void InitDefaultsSignboard();
void InitDefaultsGrabberImpl();
void InitDefaultsGrabber();
void InitDefaultsLidarStatusImpl();
void InitDefaultsLidarStatus();
void InitDefaultsBoundingBoxImpl();
void InitDefaultsBoundingBox();
void InitDefaultsCanSignalImpl();
void InitDefaultsCanSignal();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
inline void InitDefaults() {
  InitDefaultsHeader();
  InitDefaultsPointCloud();
  InitDefaultsFreespace();
  InitDefaultsTrailer();
  InitDefaultsBridge();
  InitDefaultsBoundary();
  InitDefaultsContainer();
  InitDefaultsSignboard();
  InitDefaultsGrabber();
  InitDefaultsLidarStatus();
  InitDefaultsBoundingBox();
  InitDefaultsCanSignal();
  InitDefaultsMessage();
}
}  // namespace protobuf_msg_2eproto
namespace itd {
namespace communication {
namespace protobuf {
class Boundary;
class BoundaryDefaultTypeInternal;
extern BoundaryDefaultTypeInternal _Boundary_default_instance_;
class BoundingBox;
class BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class Bridge;
class BridgeDefaultTypeInternal;
extern BridgeDefaultTypeInternal _Bridge_default_instance_;
class CanSignal;
class CanSignalDefaultTypeInternal;
extern CanSignalDefaultTypeInternal _CanSignal_default_instance_;
class Container;
class ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
class Freespace;
class FreespaceDefaultTypeInternal;
extern FreespaceDefaultTypeInternal _Freespace_default_instance_;
class Grabber;
class GrabberDefaultTypeInternal;
extern GrabberDefaultTypeInternal _Grabber_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class LidarStatus;
class LidarStatusDefaultTypeInternal;
extern LidarStatusDefaultTypeInternal _LidarStatus_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class Signboard;
class SignboardDefaultTypeInternal;
extern SignboardDefaultTypeInternal _Signboard_default_instance_;
class Trailer;
class TrailerDefaultTypeInternal;
extern TrailerDefaultTypeInternal _Trailer_default_instance_;
}  // namespace protobuf
}  // namespace communication
}  // namespace itd
namespace itd {
namespace communication {
namespace protobuf {

enum Message_MessageType {
  Message_MessageType_PointCloud = 0,
  Message_MessageType_Freespace = 1,
  Message_MessageType_Trailer = 2,
  Message_MessageType_Bridge = 3,
  Message_MessageType_Boundary = 4,
  Message_MessageType_Container = 5,
  Message_MessageType_Signboard = 6,
  Message_MessageType_LidarStatus = 7,
  Message_MessageType_BoundingBox = 8,
  Message_MessageType_CanSignal = 9,
  Message_MessageType_Message_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Message_MessageType_Message_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_MessageType_IsValid(int value);
const Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_PointCloud;
const Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_CanSignal;
const int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_MessageType_descriptor();
inline const ::std::string& Message_MessageType_Name(Message_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_MessageType_descriptor(), value);
}
inline bool Message_MessageType_Parse(
    const ::std::string& name, Message_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Header* other);
  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  protected:
  explicit Header(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string frame_id = 3;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 3;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_frame_id();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_frame_id(
      ::std::string* frame_id);

  // uint32 seq = 1;
  void clear_seq();
  static const int kSeqFieldNumber = 1;
  ::google::protobuf::uint32 seq() const;
  void set_seq(::google::protobuf::uint32 value);

  // int32 stamp = 2;
  void clear_stamp();
  static const int kStampFieldNumber = 2;
  ::google::protobuf::int32 stamp() const;
  void set_stamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::uint32 seq_;
  ::google::protobuf::int32 stamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class PointCloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(PointCloud* other);
  void Swap(PointCloud* other);
  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const PROTOBUF_FINAL { return New(NULL); }

  PointCloud* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PointCloud* other);
  protected:
  explicit PointCloud(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float x = 4;
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 4;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 5;
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 5;
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // repeated float z = 6;
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 6;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // repeated float intensity = 7;
  int intensity_size() const;
  void clear_intensity();
  static const int kIntensityFieldNumber = 7;
  float intensity(int index) const;
  void set_intensity(int index, float value);
  void add_intensity(float value);
  const ::google::protobuf::RepeatedField< float >&
      intensity() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_intensity();

  // repeated float ring = 8;
  int ring_size() const;
  void clear_ring();
  static const int kRingFieldNumber = 8;
  float ring(int index) const;
  void set_ring(int index, float value);
  void add_ring(float value);
  const ::google::protobuf::RepeatedField< float >&
      ring() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_ring();

  // repeated float azimuth = 9;
  int azimuth_size() const;
  void clear_azimuth();
  static const int kAzimuthFieldNumber = 9;
  float azimuth(int index) const;
  void set_azimuth(int index, float value);
  void add_azimuth(float value);
  const ::google::protobuf::RepeatedField< float >&
      azimuth() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_azimuth();

  // repeated float hor = 10;
  int hor_size() const;
  void clear_hor();
  static const int kHorFieldNumber = 10;
  float hor(int index) const;
  void set_hor(int index, float value);
  void add_hor(float value);
  const ::google::protobuf::RepeatedField< float >&
      hor() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_hor();

  // repeated float time_offset = 11;
  int time_offset_size() const;
  void clear_time_offset();
  static const int kTimeOffsetFieldNumber = 11;
  float time_offset(int index) const;
  void set_time_offset(int index, float value);
  void add_time_offset(float value);
  const ::google::protobuf::RepeatedField< float >&
      time_offset() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_time_offset();

  // repeated float distance = 12;
  int distance_size() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 12;
  float distance(int index) const;
  void set_distance(int index, float value);
  void add_distance(float value);
  const ::google::protobuf::RepeatedField< float >&
      distance() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_distance();

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // uint32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // uint32 width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.PointCloud)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > z_;
  mutable int _z_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > intensity_;
  mutable int _intensity_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > ring_;
  mutable int _ring_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > azimuth_;
  mutable int _azimuth_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > hor_;
  mutable int _hor_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > time_offset_;
  mutable int _time_offset_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > distance_;
  mutable int _distance_cached_byte_size_;
  ::itd::communication::protobuf::Header* header_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsPointCloudImpl();
};
// -------------------------------------------------------------------

class Freespace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Freespace) */ {
 public:
  Freespace();
  virtual ~Freespace();

  Freespace(const Freespace& from);

  inline Freespace& operator=(const Freespace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Freespace(Freespace&& from) noexcept
    : Freespace() {
    *this = ::std::move(from);
  }

  inline Freespace& operator=(Freespace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Freespace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Freespace* internal_default_instance() {
    return reinterpret_cast<const Freespace*>(
               &_Freespace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Freespace* other);
  void Swap(Freespace* other);
  friend void swap(Freespace& a, Freespace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Freespace* New() const PROTOBUF_FINAL { return New(NULL); }

  Freespace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Freespace& from);
  void MergeFrom(const Freespace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Freespace* other);
  protected:
  explicit Freespace(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float distance = 2;
  int distance_size() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance(int index) const;
  void set_distance(int index, float value);
  void add_distance(float value);
  const ::google::protobuf::RepeatedField< float >&
      distance() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_distance();

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Freespace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > distance_;
  mutable int _distance_cached_byte_size_;
  ::itd::communication::protobuf::Header* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsFreespaceImpl();
};
// -------------------------------------------------------------------

class Trailer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Trailer) */ {
 public:
  Trailer();
  virtual ~Trailer();

  Trailer(const Trailer& from);

  inline Trailer& operator=(const Trailer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trailer(Trailer&& from) noexcept
    : Trailer() {
    *this = ::std::move(from);
  }

  inline Trailer& operator=(Trailer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trailer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trailer* internal_default_instance() {
    return reinterpret_cast<const Trailer*>(
               &_Trailer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Trailer* other);
  void Swap(Trailer* other);
  friend void swap(Trailer& a, Trailer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trailer* New() const PROTOBUF_FINAL { return New(NULL); }

  Trailer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trailer& from);
  void MergeFrom(const Trailer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trailer* other);
  protected:
  explicit Trailer(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float k = 2;
  void clear_k();
  static const int kKFieldNumber = 2;
  float k() const;
  void set_k(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // int32 flag = 4;
  void clear_flag();
  static const int kFlagFieldNumber = 4;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Trailer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float k_;
  float b_;
  ::google::protobuf::int32 flag_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsTrailerImpl();
};
// -------------------------------------------------------------------

class Bridge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Bridge) */ {
 public:
  Bridge();
  virtual ~Bridge();

  Bridge(const Bridge& from);

  inline Bridge& operator=(const Bridge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bridge(Bridge&& from) noexcept
    : Bridge() {
    *this = ::std::move(from);
  }

  inline Bridge& operator=(Bridge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bridge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bridge* internal_default_instance() {
    return reinterpret_cast<const Bridge*>(
               &_Bridge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Bridge* other);
  void Swap(Bridge* other);
  friend void swap(Bridge& a, Bridge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bridge* New() const PROTOBUF_FINAL { return New(NULL); }

  Bridge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bridge& from);
  void MergeFrom(const Bridge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bridge* other);
  protected:
  explicit Bridge(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float k = 2;
  void clear_k();
  static const int kKFieldNumber = 2;
  float k() const;
  void set_k(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // int32 flag = 4;
  void clear_flag();
  static const int kFlagFieldNumber = 4;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Bridge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float k_;
  float b_;
  ::google::protobuf::int32 flag_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsBridgeImpl();
};
// -------------------------------------------------------------------

class Boundary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Boundary) */ {
 public:
  Boundary();
  virtual ~Boundary();

  Boundary(const Boundary& from);

  inline Boundary& operator=(const Boundary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Boundary(Boundary&& from) noexcept
    : Boundary() {
    *this = ::std::move(from);
  }

  inline Boundary& operator=(Boundary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Boundary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Boundary* internal_default_instance() {
    return reinterpret_cast<const Boundary*>(
               &_Boundary_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Boundary* other);
  void Swap(Boundary* other);
  friend void swap(Boundary& a, Boundary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Boundary* New() const PROTOBUF_FINAL { return New(NULL); }

  Boundary* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Boundary& from);
  void MergeFrom(const Boundary& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Boundary* other);
  protected:
  explicit Boundary(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float k = 2;
  void clear_k();
  static const int kKFieldNumber = 2;
  float k() const;
  void set_k(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // int32 flag = 4;
  void clear_flag();
  static const int kFlagFieldNumber = 4;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Boundary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float k_;
  float b_;
  ::google::protobuf::int32 flag_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsBoundaryImpl();
};
// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(Container* other);
  void Swap(Container* other);
  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const PROTOBUF_FINAL { return New(NULL); }

  Container* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Container* other);
  protected:
  explicit Container(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // int32 flag = 3;
  void clear_flag();
  static const int kFlagFieldNumber = 3;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Container)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float distance_;
  ::google::protobuf::int32 flag_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsContainerImpl();
};
// -------------------------------------------------------------------

class Signboard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Signboard) */ {
 public:
  Signboard();
  virtual ~Signboard();

  Signboard(const Signboard& from);

  inline Signboard& operator=(const Signboard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signboard(Signboard&& from) noexcept
    : Signboard() {
    *this = ::std::move(from);
  }

  inline Signboard& operator=(Signboard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signboard* internal_default_instance() {
    return reinterpret_cast<const Signboard*>(
               &_Signboard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(Signboard* other);
  void Swap(Signboard* other);
  friend void swap(Signboard& a, Signboard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signboard* New() const PROTOBUF_FINAL { return New(NULL); }

  Signboard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signboard& from);
  void MergeFrom(const Signboard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signboard* other);
  protected:
  explicit Signboard(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float k = 2;
  void clear_k();
  static const int kKFieldNumber = 2;
  float k() const;
  void set_k(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // float x = 4;
  void clear_x();
  static const int kXFieldNumber = 4;
  float x() const;
  void set_x(float value);

  // float y = 5;
  void clear_y();
  static const int kYFieldNumber = 5;
  float y() const;
  void set_y(float value);

  // int32 type = 6;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Signboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float k_;
  float b_;
  float x_;
  float y_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsSignboardImpl();
};
// -------------------------------------------------------------------

class Grabber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Grabber) */ {
 public:
  Grabber();
  virtual ~Grabber();

  Grabber(const Grabber& from);

  inline Grabber& operator=(const Grabber& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Grabber(Grabber&& from) noexcept
    : Grabber() {
    *this = ::std::move(from);
  }

  inline Grabber& operator=(Grabber&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Grabber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Grabber* internal_default_instance() {
    return reinterpret_cast<const Grabber*>(
               &_Grabber_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(Grabber* other);
  void Swap(Grabber* other);
  friend void swap(Grabber& a, Grabber& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Grabber* New() const PROTOBUF_FINAL { return New(NULL); }

  Grabber* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Grabber& from);
  void MergeFrom(const Grabber& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Grabber* other);
  protected:
  explicit Grabber(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // int32 left_angle = 2;
  void clear_left_angle();
  static const int kLeftAngleFieldNumber = 2;
  ::google::protobuf::int32 left_angle() const;
  void set_left_angle(::google::protobuf::int32 value);

  // int32 right_angle = 3;
  void clear_right_angle();
  static const int kRightAngleFieldNumber = 3;
  ::google::protobuf::int32 right_angle() const;
  void set_right_angle(::google::protobuf::int32 value);

  // float left_obstacle_dis = 4;
  void clear_left_obstacle_dis();
  static const int kLeftObstacleDisFieldNumber = 4;
  float left_obstacle_dis() const;
  void set_left_obstacle_dis(float value);

  // float right_obstacle_dis = 5;
  void clear_right_obstacle_dis();
  static const int kRightObstacleDisFieldNumber = 5;
  float right_obstacle_dis() const;
  void set_right_obstacle_dis(float value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Grabber)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  ::google::protobuf::int32 left_angle_;
  ::google::protobuf::int32 right_angle_;
  float left_obstacle_dis_;
  float right_obstacle_dis_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsGrabberImpl();
};
// -------------------------------------------------------------------

class LidarStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.LidarStatus) */ {
 public:
  LidarStatus();
  virtual ~LidarStatus();

  LidarStatus(const LidarStatus& from);

  inline LidarStatus& operator=(const LidarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarStatus(LidarStatus&& from) noexcept
    : LidarStatus() {
    *this = ::std::move(from);
  }

  inline LidarStatus& operator=(LidarStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarStatus* internal_default_instance() {
    return reinterpret_cast<const LidarStatus*>(
               &_LidarStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(LidarStatus* other);
  void Swap(LidarStatus* other);
  friend void swap(LidarStatus& a, LidarStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarStatus& from);
  void MergeFrom(const LidarStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarStatus* other);
  protected:
  explicit LidarStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // int32 left = 2;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  ::google::protobuf::int32 left() const;
  void set_left(::google::protobuf::int32 value);

  // int32 right = 3;
  void clear_right();
  static const int kRightFieldNumber = 3;
  ::google::protobuf::int32 right() const;
  void set_right(::google::protobuf::int32 value);

  // int32 top = 4;
  void clear_top();
  static const int kTopFieldNumber = 4;
  ::google::protobuf::int32 top() const;
  void set_top(::google::protobuf::int32 value);

  // int32 single = 5;
  void clear_single();
  static const int kSingleFieldNumber = 5;
  ::google::protobuf::int32 single() const;
  void set_single(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.LidarStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 single_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsLidarStatusImpl();
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.BoundingBox) */ {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(BoundingBox* other);
  void Swap(BoundingBox* other);
  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundingBox* New() const PROTOBUF_FINAL { return New(NULL); }

  BoundingBox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoundingBox* other);
  protected:
  explicit BoundingBox(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float head_angle = 3;
  int head_angle_size() const;
  void clear_head_angle();
  static const int kHeadAngleFieldNumber = 3;
  float head_angle(int index) const;
  void set_head_angle(int index, float value);
  void add_head_angle(float value);
  const ::google::protobuf::RepeatedField< float >&
      head_angle() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_head_angle();

  // repeated float length_obj = 4;
  int length_obj_size() const;
  void clear_length_obj();
  static const int kLengthObjFieldNumber = 4;
  float length_obj(int index) const;
  void set_length_obj(int index, float value);
  void add_length_obj(float value);
  const ::google::protobuf::RepeatedField< float >&
      length_obj() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_length_obj();

  // repeated float width_obj = 5;
  int width_obj_size() const;
  void clear_width_obj();
  static const int kWidthObjFieldNumber = 5;
  float width_obj(int index) const;
  void set_width_obj(int index, float value);
  void add_width_obj(float value);
  const ::google::protobuf::RepeatedField< float >&
      width_obj() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_width_obj();

  // repeated float track_id = 6;
  int track_id_size() const;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 6;
  float track_id(int index) const;
  void set_track_id(int index, float value);
  void add_track_id(float value);
  const ::google::protobuf::RepeatedField< float >&
      track_id() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_track_id();

  // repeated float vx = 7;
  int vx_size() const;
  void clear_vx();
  static const int kVxFieldNumber = 7;
  float vx(int index) const;
  void set_vx(int index, float value);
  void add_vx(float value);
  const ::google::protobuf::RepeatedField< float >&
      vx() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_vx();

  // repeated float vy = 8;
  int vy_size() const;
  void clear_vy();
  static const int kVyFieldNumber = 8;
  float vy(int index) const;
  void set_vy(int index, float value);
  void add_vy(float value);
  const ::google::protobuf::RepeatedField< float >&
      vy() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_vy();

  // repeated float x = 9;
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 9;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 10;
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 10;
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // int32 number = 2;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.BoundingBox)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > head_angle_;
  mutable int _head_angle_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > length_obj_;
  mutable int _length_obj_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > width_obj_;
  mutable int _width_obj_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > track_id_;
  mutable int _track_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > vx_;
  mutable int _vx_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > vy_;
  mutable int _vy_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > y_;
  mutable int _y_cached_byte_size_;
  ::itd::communication::protobuf::Header* header_;
  ::google::protobuf::int32 number_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsBoundingBoxImpl();
};
// -------------------------------------------------------------------

class CanSignal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.CanSignal) */ {
 public:
  CanSignal();
  virtual ~CanSignal();

  CanSignal(const CanSignal& from);

  inline CanSignal& operator=(const CanSignal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CanSignal(CanSignal&& from) noexcept
    : CanSignal() {
    *this = ::std::move(from);
  }

  inline CanSignal& operator=(CanSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CanSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CanSignal* internal_default_instance() {
    return reinterpret_cast<const CanSignal*>(
               &_CanSignal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(CanSignal* other);
  void Swap(CanSignal* other);
  friend void swap(CanSignal& a, CanSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CanSignal* New() const PROTOBUF_FINAL { return New(NULL); }

  CanSignal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CanSignal& from);
  void MergeFrom(const CanSignal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CanSignal* other);
  protected:
  explicit CanSignal(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double signal = 3;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 3;
  double signal(int index) const;
  void set_signal(int index, double value);
  void add_signal(double value);
  const ::google::protobuf::RepeatedField< double >&
      signal() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_signal();

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // int32 nb_signal = 2;
  void clear_nb_signal();
  static const int kNbSignalFieldNumber = 2;
  ::google::protobuf::int32 nb_signal() const;
  void set_nb_signal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.CanSignal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< double > signal_;
  mutable int _signal_cached_byte_size_;
  ::itd::communication::protobuf::Header* header_;
  ::google::protobuf::int32 nb_signal_;
  mutable int _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsCanSignalImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MsgCase {
    kCloud = 11,
    kFs = 12,
    kTrailer = 13,
    kBridge = 14,
    kBoundary = 15,
    kContainer = 16,
    kSignboard = 17,
    kLidarStatus = 18,
    kBoundingBox = 19,
    kCanSignal = 20,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(Message* other);
  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  protected:
  explicit Message(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Message_MessageType MessageType;
  static const MessageType PointCloud =
    Message_MessageType_PointCloud;
  static const MessageType Freespace =
    Message_MessageType_Freespace;
  static const MessageType Trailer =
    Message_MessageType_Trailer;
  static const MessageType Bridge =
    Message_MessageType_Bridge;
  static const MessageType Boundary =
    Message_MessageType_Boundary;
  static const MessageType Container =
    Message_MessageType_Container;
  static const MessageType Signboard =
    Message_MessageType_Signboard;
  static const MessageType LidarStatus =
    Message_MessageType_LidarStatus;
  static const MessageType BoundingBox =
    Message_MessageType_BoundingBox;
  static const MessageType CanSignal =
    Message_MessageType_CanSignal;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Message_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Message.MessageType type = 10;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  ::itd::communication::protobuf::Message_MessageType type() const;
  void set_type(::itd::communication::protobuf::Message_MessageType value);

  // .itd.communication.protobuf.PointCloud cloud = 11;
  bool has_cloud() const;
  void clear_cloud();
  static const int kCloudFieldNumber = 11;
  private:
  void _slow_mutable_cloud();
  public:
  const ::itd::communication::protobuf::PointCloud& cloud() const;
  ::itd::communication::protobuf::PointCloud* release_cloud();
  ::itd::communication::protobuf::PointCloud* mutable_cloud();
  void set_allocated_cloud(::itd::communication::protobuf::PointCloud* cloud);
  void unsafe_arena_set_allocated_cloud(
      ::itd::communication::protobuf::PointCloud* cloud);
  ::itd::communication::protobuf::PointCloud* unsafe_arena_release_cloud();

  // .itd.communication.protobuf.Freespace fs = 12;
  bool has_fs() const;
  void clear_fs();
  static const int kFsFieldNumber = 12;
  private:
  void _slow_mutable_fs();
  public:
  const ::itd::communication::protobuf::Freespace& fs() const;
  ::itd::communication::protobuf::Freespace* release_fs();
  ::itd::communication::protobuf::Freespace* mutable_fs();
  void set_allocated_fs(::itd::communication::protobuf::Freespace* fs);
  void unsafe_arena_set_allocated_fs(
      ::itd::communication::protobuf::Freespace* fs);
  ::itd::communication::protobuf::Freespace* unsafe_arena_release_fs();

  // .itd.communication.protobuf.Trailer trailer = 13;
  bool has_trailer() const;
  void clear_trailer();
  static const int kTrailerFieldNumber = 13;
  private:
  void _slow_mutable_trailer();
  public:
  const ::itd::communication::protobuf::Trailer& trailer() const;
  ::itd::communication::protobuf::Trailer* release_trailer();
  ::itd::communication::protobuf::Trailer* mutable_trailer();
  void set_allocated_trailer(::itd::communication::protobuf::Trailer* trailer);
  void unsafe_arena_set_allocated_trailer(
      ::itd::communication::protobuf::Trailer* trailer);
  ::itd::communication::protobuf::Trailer* unsafe_arena_release_trailer();

  // .itd.communication.protobuf.Bridge bridge = 14;
  bool has_bridge() const;
  void clear_bridge();
  static const int kBridgeFieldNumber = 14;
  private:
  void _slow_mutable_bridge();
  public:
  const ::itd::communication::protobuf::Bridge& bridge() const;
  ::itd::communication::protobuf::Bridge* release_bridge();
  ::itd::communication::protobuf::Bridge* mutable_bridge();
  void set_allocated_bridge(::itd::communication::protobuf::Bridge* bridge);
  void unsafe_arena_set_allocated_bridge(
      ::itd::communication::protobuf::Bridge* bridge);
  ::itd::communication::protobuf::Bridge* unsafe_arena_release_bridge();

  // .itd.communication.protobuf.Boundary boundary = 15;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 15;
  private:
  void _slow_mutable_boundary();
  public:
  const ::itd::communication::protobuf::Boundary& boundary() const;
  ::itd::communication::protobuf::Boundary* release_boundary();
  ::itd::communication::protobuf::Boundary* mutable_boundary();
  void set_allocated_boundary(::itd::communication::protobuf::Boundary* boundary);
  void unsafe_arena_set_allocated_boundary(
      ::itd::communication::protobuf::Boundary* boundary);
  ::itd::communication::protobuf::Boundary* unsafe_arena_release_boundary();

  // .itd.communication.protobuf.Container container = 16;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 16;
  private:
  void _slow_mutable_container();
  public:
  const ::itd::communication::protobuf::Container& container() const;
  ::itd::communication::protobuf::Container* release_container();
  ::itd::communication::protobuf::Container* mutable_container();
  void set_allocated_container(::itd::communication::protobuf::Container* container);
  void unsafe_arena_set_allocated_container(
      ::itd::communication::protobuf::Container* container);
  ::itd::communication::protobuf::Container* unsafe_arena_release_container();

  // .itd.communication.protobuf.Signboard signboard = 17;
  bool has_signboard() const;
  void clear_signboard();
  static const int kSignboardFieldNumber = 17;
  private:
  void _slow_mutable_signboard();
  public:
  const ::itd::communication::protobuf::Signboard& signboard() const;
  ::itd::communication::protobuf::Signboard* release_signboard();
  ::itd::communication::protobuf::Signboard* mutable_signboard();
  void set_allocated_signboard(::itd::communication::protobuf::Signboard* signboard);
  void unsafe_arena_set_allocated_signboard(
      ::itd::communication::protobuf::Signboard* signboard);
  ::itd::communication::protobuf::Signboard* unsafe_arena_release_signboard();

  // .itd.communication.protobuf.LidarStatus lidar_status = 18;
  bool has_lidar_status() const;
  void clear_lidar_status();
  static const int kLidarStatusFieldNumber = 18;
  private:
  void _slow_mutable_lidar_status();
  public:
  const ::itd::communication::protobuf::LidarStatus& lidar_status() const;
  ::itd::communication::protobuf::LidarStatus* release_lidar_status();
  ::itd::communication::protobuf::LidarStatus* mutable_lidar_status();
  void set_allocated_lidar_status(::itd::communication::protobuf::LidarStatus* lidar_status);
  void unsafe_arena_set_allocated_lidar_status(
      ::itd::communication::protobuf::LidarStatus* lidar_status);
  ::itd::communication::protobuf::LidarStatus* unsafe_arena_release_lidar_status();

  // .itd.communication.protobuf.BoundingBox boundingBox = 19;
  bool has_boundingbox() const;
  void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 19;
  private:
  void _slow_mutable_boundingbox();
  public:
  const ::itd::communication::protobuf::BoundingBox& boundingbox() const;
  ::itd::communication::protobuf::BoundingBox* release_boundingbox();
  ::itd::communication::protobuf::BoundingBox* mutable_boundingbox();
  void set_allocated_boundingbox(::itd::communication::protobuf::BoundingBox* boundingbox);
  void unsafe_arena_set_allocated_boundingbox(
      ::itd::communication::protobuf::BoundingBox* boundingbox);
  ::itd::communication::protobuf::BoundingBox* unsafe_arena_release_boundingbox();

  // .itd.communication.protobuf.CanSignal can_signal = 20;
  bool has_can_signal() const;
  void clear_can_signal();
  static const int kCanSignalFieldNumber = 20;
  private:
  void _slow_mutable_can_signal();
  public:
  const ::itd::communication::protobuf::CanSignal& can_signal() const;
  ::itd::communication::protobuf::CanSignal* release_can_signal();
  ::itd::communication::protobuf::CanSignal* mutable_can_signal();
  void set_allocated_can_signal(::itd::communication::protobuf::CanSignal* can_signal);
  void unsafe_arena_set_allocated_can_signal(
      ::itd::communication::protobuf::CanSignal* can_signal);
  ::itd::communication::protobuf::CanSignal* unsafe_arena_release_can_signal();

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Message)
 private:
  void set_has_cloud();
  void set_has_fs();
  void set_has_trailer();
  void set_has_bridge();
  void set_has_boundary();
  void set_has_container();
  void set_has_signboard();
  void set_has_lidar_status();
  void set_has_boundingbox();
  void set_has_can_signal();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  union MsgUnion {
    MsgUnion() {}
    ::itd::communication::protobuf::PointCloud* cloud_;
    ::itd::communication::protobuf::Freespace* fs_;
    ::itd::communication::protobuf::Trailer* trailer_;
    ::itd::communication::protobuf::Bridge* bridge_;
    ::itd::communication::protobuf::Boundary* boundary_;
    ::itd::communication::protobuf::Container* container_;
    ::itd::communication::protobuf::Signboard* signboard_;
    ::itd::communication::protobuf::LidarStatus* lidar_status_;
    ::itd::communication::protobuf::BoundingBox* boundingbox_;
    ::itd::communication::protobuf::CanSignal* can_signal_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_msg_2eproto::TableStruct;
  friend void ::protobuf_msg_2eproto::InitDefaultsMessageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// uint32 seq = 1;
inline void Header::clear_seq() {
  seq_ = 0u;
}
inline ::google::protobuf::uint32 Header::seq() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Header.seq)
  return seq_;
}
inline void Header::set_seq(::google::protobuf::uint32 value) {
  
  seq_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Header.seq)
}

// int32 stamp = 2;
inline void Header::clear_stamp() {
  stamp_ = 0;
}
inline ::google::protobuf::int32 Header::stamp() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Header.stamp)
  return stamp_;
}
inline void Header::set_stamp(::google::protobuf::int32 value) {
  
  stamp_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Header.stamp)
}

// string frame_id = 3;
inline void Header::clear_frame_id() {
  frame_id_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Header::frame_id() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Header.frame_id)
  return frame_id_.Get();
}
inline void Header::set_frame_id(const ::std::string& value) {
  
  frame_id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Header.frame_id)
}
#if LANG_CXX11
inline void Header::set_frame_id(::std::string&& value) {
  
  frame_id_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:itd.communication.protobuf.Header.frame_id)
}
#endif
inline void Header::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  frame_id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:itd.communication.protobuf.Header.frame_id)
}
inline void Header::set_frame_id(const char* value,
    size_t size) {
  
  frame_id_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:itd.communication.protobuf.Header.frame_id)
}
inline ::std::string* Header::mutable_frame_id() {
  
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Header.frame_id)
  return frame_id_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Header::release_frame_id() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Header.frame_id)
  
  return frame_id_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Header::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    
  } else {
    
  }
  frame_id_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Header.frame_id)
}
inline ::std::string* Header::unsafe_arena_release_frame_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Header.frame_id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return frame_id_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Header::unsafe_arena_set_allocated_frame_id(
    ::std::string* frame_id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (frame_id != NULL) {
    
  } else {
    
  }
  frame_id_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      frame_id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Header.frame_id)
}

// -------------------------------------------------------------------

// PointCloud

// .itd.communication.protobuf.Header header = 1;
inline bool PointCloud::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PointCloud::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& PointCloud::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* PointCloud::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.PointCloud.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* PointCloud::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.PointCloud.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* PointCloud::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.PointCloud.header)
  return header_;
}
inline void PointCloud::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.PointCloud.header)
}

// uint32 height = 2;
inline void PointCloud::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 PointCloud::height() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.height)
  return height_;
}
inline void PointCloud::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.height)
}

// uint32 width = 3;
inline void PointCloud::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 PointCloud::width() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.width)
  return width_;
}
inline void PointCloud::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.width)
}

// repeated float x = 4;
inline int PointCloud::x_size() const {
  return x_.size();
}
inline void PointCloud::clear_x() {
  x_.Clear();
}
inline float PointCloud::x(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.x)
  return x_.Get(index);
}
inline void PointCloud::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.x)
}
inline void PointCloud::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.x)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::x() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.x)
  return &x_;
}

// repeated float y = 5;
inline int PointCloud::y_size() const {
  return y_.size();
}
inline void PointCloud::clear_y() {
  y_.Clear();
}
inline float PointCloud::y(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.y)
  return y_.Get(index);
}
inline void PointCloud::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.y)
}
inline void PointCloud::add_y(float value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.y)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::y() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.y)
  return &y_;
}

// repeated float z = 6;
inline int PointCloud::z_size() const {
  return z_.size();
}
inline void PointCloud::clear_z() {
  z_.Clear();
}
inline float PointCloud::z(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.z)
  return z_.Get(index);
}
inline void PointCloud::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.z)
}
inline void PointCloud::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.z)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::z() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.z)
  return &z_;
}

// repeated float intensity = 7;
inline int PointCloud::intensity_size() const {
  return intensity_.size();
}
inline void PointCloud::clear_intensity() {
  intensity_.Clear();
}
inline float PointCloud::intensity(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.intensity)
  return intensity_.Get(index);
}
inline void PointCloud::set_intensity(int index, float value) {
  intensity_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.intensity)
}
inline void PointCloud::add_intensity(float value) {
  intensity_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.intensity)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::intensity() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.intensity)
  return intensity_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_intensity() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.intensity)
  return &intensity_;
}

// repeated float ring = 8;
inline int PointCloud::ring_size() const {
  return ring_.size();
}
inline void PointCloud::clear_ring() {
  ring_.Clear();
}
inline float PointCloud::ring(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.ring)
  return ring_.Get(index);
}
inline void PointCloud::set_ring(int index, float value) {
  ring_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.ring)
}
inline void PointCloud::add_ring(float value) {
  ring_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.ring)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::ring() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.ring)
  return ring_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_ring() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.ring)
  return &ring_;
}

// repeated float azimuth = 9;
inline int PointCloud::azimuth_size() const {
  return azimuth_.size();
}
inline void PointCloud::clear_azimuth() {
  azimuth_.Clear();
}
inline float PointCloud::azimuth(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.azimuth)
  return azimuth_.Get(index);
}
inline void PointCloud::set_azimuth(int index, float value) {
  azimuth_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.azimuth)
}
inline void PointCloud::add_azimuth(float value) {
  azimuth_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.azimuth)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::azimuth() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.azimuth)
  return azimuth_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_azimuth() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.azimuth)
  return &azimuth_;
}

// repeated float hor = 10;
inline int PointCloud::hor_size() const {
  return hor_.size();
}
inline void PointCloud::clear_hor() {
  hor_.Clear();
}
inline float PointCloud::hor(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.hor)
  return hor_.Get(index);
}
inline void PointCloud::set_hor(int index, float value) {
  hor_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.hor)
}
inline void PointCloud::add_hor(float value) {
  hor_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.hor)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::hor() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.hor)
  return hor_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_hor() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.hor)
  return &hor_;
}

// repeated float time_offset = 11;
inline int PointCloud::time_offset_size() const {
  return time_offset_.size();
}
inline void PointCloud::clear_time_offset() {
  time_offset_.Clear();
}
inline float PointCloud::time_offset(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.time_offset)
  return time_offset_.Get(index);
}
inline void PointCloud::set_time_offset(int index, float value) {
  time_offset_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.time_offset)
}
inline void PointCloud::add_time_offset(float value) {
  time_offset_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.time_offset)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::time_offset() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.time_offset)
  return time_offset_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_time_offset() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.time_offset)
  return &time_offset_;
}

// repeated float distance = 12;
inline int PointCloud::distance_size() const {
  return distance_.size();
}
inline void PointCloud::clear_distance() {
  distance_.Clear();
}
inline float PointCloud::distance(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.PointCloud.distance)
  return distance_.Get(index);
}
inline void PointCloud::set_distance(int index, float value) {
  distance_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.PointCloud.distance)
}
inline void PointCloud::add_distance(float value) {
  distance_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.PointCloud.distance)
}
inline const ::google::protobuf::RepeatedField< float >&
PointCloud::distance() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.PointCloud.distance)
  return distance_;
}
inline ::google::protobuf::RepeatedField< float >*
PointCloud::mutable_distance() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.PointCloud.distance)
  return &distance_;
}

// -------------------------------------------------------------------

// Freespace

// .itd.communication.protobuf.Header header = 1;
inline bool Freespace::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Freespace::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Freespace::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Freespace.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Freespace::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Freespace.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Freespace::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Freespace.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Freespace::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Freespace.header)
  return header_;
}
inline void Freespace::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Freespace.header)
}

// repeated float distance = 2;
inline int Freespace::distance_size() const {
  return distance_.size();
}
inline void Freespace::clear_distance() {
  distance_.Clear();
}
inline float Freespace::distance(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Freespace.distance)
  return distance_.Get(index);
}
inline void Freespace::set_distance(int index, float value) {
  distance_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Freespace.distance)
}
inline void Freespace::add_distance(float value) {
  distance_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Freespace.distance)
}
inline const ::google::protobuf::RepeatedField< float >&
Freespace::distance() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Freespace.distance)
  return distance_;
}
inline ::google::protobuf::RepeatedField< float >*
Freespace::mutable_distance() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Freespace.distance)
  return &distance_;
}

// -------------------------------------------------------------------

// Trailer

// .itd.communication.protobuf.Header header = 1;
inline bool Trailer::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Trailer::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Trailer::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Trailer.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Trailer::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Trailer.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Trailer::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Trailer.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Trailer::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Trailer.header)
  return header_;
}
inline void Trailer::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Trailer.header)
}

// float k = 2;
inline void Trailer::clear_k() {
  k_ = 0;
}
inline float Trailer::k() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Trailer.k)
  return k_;
}
inline void Trailer::set_k(float value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Trailer.k)
}

// float b = 3;
inline void Trailer::clear_b() {
  b_ = 0;
}
inline float Trailer::b() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Trailer.b)
  return b_;
}
inline void Trailer::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Trailer.b)
}

// int32 flag = 4;
inline void Trailer::clear_flag() {
  flag_ = 0;
}
inline ::google::protobuf::int32 Trailer::flag() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Trailer.flag)
  return flag_;
}
inline void Trailer::set_flag(::google::protobuf::int32 value) {
  
  flag_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Trailer.flag)
}

// -------------------------------------------------------------------

// Bridge

// .itd.communication.protobuf.Header header = 1;
inline bool Bridge::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Bridge::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Bridge::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Bridge.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Bridge::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Bridge.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Bridge::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Bridge.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Bridge::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Bridge.header)
  return header_;
}
inline void Bridge::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Bridge.header)
}

// float k = 2;
inline void Bridge::clear_k() {
  k_ = 0;
}
inline float Bridge::k() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Bridge.k)
  return k_;
}
inline void Bridge::set_k(float value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Bridge.k)
}

// float b = 3;
inline void Bridge::clear_b() {
  b_ = 0;
}
inline float Bridge::b() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Bridge.b)
  return b_;
}
inline void Bridge::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Bridge.b)
}

// int32 flag = 4;
inline void Bridge::clear_flag() {
  flag_ = 0;
}
inline ::google::protobuf::int32 Bridge::flag() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Bridge.flag)
  return flag_;
}
inline void Bridge::set_flag(::google::protobuf::int32 value) {
  
  flag_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Bridge.flag)
}

// -------------------------------------------------------------------

// Boundary

// .itd.communication.protobuf.Header header = 1;
inline bool Boundary::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Boundary::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Boundary::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Boundary.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Boundary::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Boundary.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Boundary::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Boundary.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Boundary::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Boundary.header)
  return header_;
}
inline void Boundary::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Boundary.header)
}

// float k = 2;
inline void Boundary::clear_k() {
  k_ = 0;
}
inline float Boundary::k() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Boundary.k)
  return k_;
}
inline void Boundary::set_k(float value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Boundary.k)
}

// float b = 3;
inline void Boundary::clear_b() {
  b_ = 0;
}
inline float Boundary::b() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Boundary.b)
  return b_;
}
inline void Boundary::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Boundary.b)
}

// int32 flag = 4;
inline void Boundary::clear_flag() {
  flag_ = 0;
}
inline ::google::protobuf::int32 Boundary::flag() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Boundary.flag)
  return flag_;
}
inline void Boundary::set_flag(::google::protobuf::int32 value) {
  
  flag_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Boundary.flag)
}

// -------------------------------------------------------------------

// Container

// .itd.communication.protobuf.Header header = 1;
inline bool Container::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Container::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Container::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Container.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Container::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Container.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Container::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Container.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Container::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Container.header)
  return header_;
}
inline void Container::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Container.header)
}

// float distance = 2;
inline void Container::clear_distance() {
  distance_ = 0;
}
inline float Container::distance() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Container.distance)
  return distance_;
}
inline void Container::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Container.distance)
}

// int32 flag = 3;
inline void Container::clear_flag() {
  flag_ = 0;
}
inline ::google::protobuf::int32 Container::flag() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Container.flag)
  return flag_;
}
inline void Container::set_flag(::google::protobuf::int32 value) {
  
  flag_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Container.flag)
}

// -------------------------------------------------------------------

// Signboard

// .itd.communication.protobuf.Header header = 1;
inline bool Signboard::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Signboard::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Signboard::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Signboard.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Signboard::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Signboard.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Signboard::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Signboard.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Signboard::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Signboard.header)
  return header_;
}
inline void Signboard::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Signboard.header)
}

// float k = 2;
inline void Signboard::clear_k() {
  k_ = 0;
}
inline float Signboard::k() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Signboard.k)
  return k_;
}
inline void Signboard::set_k(float value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Signboard.k)
}

// float b = 3;
inline void Signboard::clear_b() {
  b_ = 0;
}
inline float Signboard::b() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Signboard.b)
  return b_;
}
inline void Signboard::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Signboard.b)
}

// float x = 4;
inline void Signboard::clear_x() {
  x_ = 0;
}
inline float Signboard::x() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Signboard.x)
  return x_;
}
inline void Signboard::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Signboard.x)
}

// float y = 5;
inline void Signboard::clear_y() {
  y_ = 0;
}
inline float Signboard::y() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Signboard.y)
  return y_;
}
inline void Signboard::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Signboard.y)
}

// int32 type = 6;
inline void Signboard::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 Signboard::type() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Signboard.type)
  return type_;
}
inline void Signboard::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Signboard.type)
}

// -------------------------------------------------------------------

// Grabber

// .itd.communication.protobuf.Header header = 1;
inline bool Grabber::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Grabber::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& Grabber::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Grabber.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Grabber::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Grabber.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Grabber::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Grabber.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Grabber::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Grabber.header)
  return header_;
}
inline void Grabber::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Grabber.header)
}

// int32 left_angle = 2;
inline void Grabber::clear_left_angle() {
  left_angle_ = 0;
}
inline ::google::protobuf::int32 Grabber::left_angle() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Grabber.left_angle)
  return left_angle_;
}
inline void Grabber::set_left_angle(::google::protobuf::int32 value) {
  
  left_angle_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Grabber.left_angle)
}

// int32 right_angle = 3;
inline void Grabber::clear_right_angle() {
  right_angle_ = 0;
}
inline ::google::protobuf::int32 Grabber::right_angle() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Grabber.right_angle)
  return right_angle_;
}
inline void Grabber::set_right_angle(::google::protobuf::int32 value) {
  
  right_angle_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Grabber.right_angle)
}

// float left_obstacle_dis = 4;
inline void Grabber::clear_left_obstacle_dis() {
  left_obstacle_dis_ = 0;
}
inline float Grabber::left_obstacle_dis() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Grabber.left_obstacle_dis)
  return left_obstacle_dis_;
}
inline void Grabber::set_left_obstacle_dis(float value) {
  
  left_obstacle_dis_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Grabber.left_obstacle_dis)
}

// float right_obstacle_dis = 5;
inline void Grabber::clear_right_obstacle_dis() {
  right_obstacle_dis_ = 0;
}
inline float Grabber::right_obstacle_dis() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Grabber.right_obstacle_dis)
  return right_obstacle_dis_;
}
inline void Grabber::set_right_obstacle_dis(float value) {
  
  right_obstacle_dis_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Grabber.right_obstacle_dis)
}

// -------------------------------------------------------------------

// LidarStatus

// .itd.communication.protobuf.Header header = 1;
inline bool LidarStatus::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void LidarStatus::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& LidarStatus::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.LidarStatus.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* LidarStatus::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.LidarStatus.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* LidarStatus::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.LidarStatus.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* LidarStatus::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.LidarStatus.header)
  return header_;
}
inline void LidarStatus::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.LidarStatus.header)
}

// int32 left = 2;
inline void LidarStatus::clear_left() {
  left_ = 0;
}
inline ::google::protobuf::int32 LidarStatus::left() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.LidarStatus.left)
  return left_;
}
inline void LidarStatus::set_left(::google::protobuf::int32 value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.LidarStatus.left)
}

// int32 right = 3;
inline void LidarStatus::clear_right() {
  right_ = 0;
}
inline ::google::protobuf::int32 LidarStatus::right() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.LidarStatus.right)
  return right_;
}
inline void LidarStatus::set_right(::google::protobuf::int32 value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.LidarStatus.right)
}

// int32 top = 4;
inline void LidarStatus::clear_top() {
  top_ = 0;
}
inline ::google::protobuf::int32 LidarStatus::top() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.LidarStatus.top)
  return top_;
}
inline void LidarStatus::set_top(::google::protobuf::int32 value) {
  
  top_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.LidarStatus.top)
}

// int32 single = 5;
inline void LidarStatus::clear_single() {
  single_ = 0;
}
inline ::google::protobuf::int32 LidarStatus::single() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.LidarStatus.single)
  return single_;
}
inline void LidarStatus::set_single(::google::protobuf::int32 value) {
  
  single_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.LidarStatus.single)
}

// -------------------------------------------------------------------

// BoundingBox

// .itd.communication.protobuf.Header header = 1;
inline bool BoundingBox::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void BoundingBox::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& BoundingBox::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* BoundingBox::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.BoundingBox.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* BoundingBox::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.BoundingBox.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* BoundingBox::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.BoundingBox.header)
  return header_;
}
inline void BoundingBox::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.BoundingBox.header)
}

// int32 number = 2;
inline void BoundingBox::clear_number() {
  number_ = 0;
}
inline ::google::protobuf::int32 BoundingBox::number() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.number)
  return number_;
}
inline void BoundingBox::set_number(::google::protobuf::int32 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.number)
}

// repeated float head_angle = 3;
inline int BoundingBox::head_angle_size() const {
  return head_angle_.size();
}
inline void BoundingBox::clear_head_angle() {
  head_angle_.Clear();
}
inline float BoundingBox::head_angle(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.head_angle)
  return head_angle_.Get(index);
}
inline void BoundingBox::set_head_angle(int index, float value) {
  head_angle_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.head_angle)
}
inline void BoundingBox::add_head_angle(float value) {
  head_angle_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.head_angle)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::head_angle() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.head_angle)
  return head_angle_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_head_angle() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.head_angle)
  return &head_angle_;
}

// repeated float length_obj = 4;
inline int BoundingBox::length_obj_size() const {
  return length_obj_.size();
}
inline void BoundingBox::clear_length_obj() {
  length_obj_.Clear();
}
inline float BoundingBox::length_obj(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.length_obj)
  return length_obj_.Get(index);
}
inline void BoundingBox::set_length_obj(int index, float value) {
  length_obj_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.length_obj)
}
inline void BoundingBox::add_length_obj(float value) {
  length_obj_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.length_obj)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::length_obj() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.length_obj)
  return length_obj_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_length_obj() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.length_obj)
  return &length_obj_;
}

// repeated float width_obj = 5;
inline int BoundingBox::width_obj_size() const {
  return width_obj_.size();
}
inline void BoundingBox::clear_width_obj() {
  width_obj_.Clear();
}
inline float BoundingBox::width_obj(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.width_obj)
  return width_obj_.Get(index);
}
inline void BoundingBox::set_width_obj(int index, float value) {
  width_obj_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.width_obj)
}
inline void BoundingBox::add_width_obj(float value) {
  width_obj_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.width_obj)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::width_obj() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.width_obj)
  return width_obj_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_width_obj() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.width_obj)
  return &width_obj_;
}

// repeated float track_id = 6;
inline int BoundingBox::track_id_size() const {
  return track_id_.size();
}
inline void BoundingBox::clear_track_id() {
  track_id_.Clear();
}
inline float BoundingBox::track_id(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.track_id)
  return track_id_.Get(index);
}
inline void BoundingBox::set_track_id(int index, float value) {
  track_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.track_id)
}
inline void BoundingBox::add_track_id(float value) {
  track_id_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.track_id)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::track_id() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.track_id)
  return track_id_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_track_id() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.track_id)
  return &track_id_;
}

// repeated float vx = 7;
inline int BoundingBox::vx_size() const {
  return vx_.size();
}
inline void BoundingBox::clear_vx() {
  vx_.Clear();
}
inline float BoundingBox::vx(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.vx)
  return vx_.Get(index);
}
inline void BoundingBox::set_vx(int index, float value) {
  vx_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.vx)
}
inline void BoundingBox::add_vx(float value) {
  vx_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.vx)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::vx() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.vx)
  return vx_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_vx() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.vx)
  return &vx_;
}

// repeated float vy = 8;
inline int BoundingBox::vy_size() const {
  return vy_.size();
}
inline void BoundingBox::clear_vy() {
  vy_.Clear();
}
inline float BoundingBox::vy(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.vy)
  return vy_.Get(index);
}
inline void BoundingBox::set_vy(int index, float value) {
  vy_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.vy)
}
inline void BoundingBox::add_vy(float value) {
  vy_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.vy)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::vy() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.vy)
  return vy_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_vy() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.vy)
  return &vy_;
}

// repeated float x = 9;
inline int BoundingBox::x_size() const {
  return x_.size();
}
inline void BoundingBox::clear_x() {
  x_.Clear();
}
inline float BoundingBox::x(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.x)
  return x_.Get(index);
}
inline void BoundingBox::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.x)
}
inline void BoundingBox::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.x)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::x() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.x)
  return &x_;
}

// repeated float y = 10;
inline int BoundingBox::y_size() const {
  return y_.size();
}
inline void BoundingBox::clear_y() {
  y_.Clear();
}
inline float BoundingBox::y(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.BoundingBox.y)
  return y_.Get(index);
}
inline void BoundingBox::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.BoundingBox.y)
}
inline void BoundingBox::add_y(float value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.BoundingBox.y)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundingBox::y() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.BoundingBox.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundingBox::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.BoundingBox.y)
  return &y_;
}

// -------------------------------------------------------------------

// CanSignal

// .itd.communication.protobuf.Header header = 1;
inline bool CanSignal::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CanSignal::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::itd::communication::protobuf::Header& CanSignal::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.CanSignal.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* CanSignal::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.CanSignal.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* CanSignal::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.CanSignal.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* CanSignal::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.CanSignal.header)
  return header_;
}
inline void CanSignal::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.CanSignal.header)
}

// int32 nb_signal = 2;
inline void CanSignal::clear_nb_signal() {
  nb_signal_ = 0;
}
inline ::google::protobuf::int32 CanSignal::nb_signal() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.CanSignal.nb_signal)
  return nb_signal_;
}
inline void CanSignal::set_nb_signal(::google::protobuf::int32 value) {
  
  nb_signal_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.CanSignal.nb_signal)
}

// repeated double signal = 3;
inline int CanSignal::signal_size() const {
  return signal_.size();
}
inline void CanSignal::clear_signal() {
  signal_.Clear();
}
inline double CanSignal::signal(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.CanSignal.signal)
  return signal_.Get(index);
}
inline void CanSignal::set_signal(int index, double value) {
  signal_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.CanSignal.signal)
}
inline void CanSignal::add_signal(double value) {
  signal_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.CanSignal.signal)
}
inline const ::google::protobuf::RepeatedField< double >&
CanSignal::signal() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.CanSignal.signal)
  return signal_;
}
inline ::google::protobuf::RepeatedField< double >*
CanSignal::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.CanSignal.signal)
  return &signal_;
}

// -------------------------------------------------------------------

// Message

// .itd.communication.protobuf.Message.MessageType type = 10;
inline void Message::clear_type() {
  type_ = 0;
}
inline ::itd::communication::protobuf::Message_MessageType Message::type() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.type)
  return static_cast< ::itd::communication::protobuf::Message_MessageType >(type_);
}
inline void Message::set_type(::itd::communication::protobuf::Message_MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Message.type)
}

// .itd.communication.protobuf.PointCloud cloud = 11;
inline bool Message::has_cloud() const {
  return msg_case() == kCloud;
}
inline void Message::set_has_cloud() {
  _oneof_case_[0] = kCloud;
}
inline void Message::clear_cloud() {
  if (has_cloud()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.cloud_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::PointCloud* Message::release_cloud() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.cloud)
  if (has_cloud()) {
    clear_has_msg();
      ::itd::communication::protobuf::PointCloud* temp = msg_.cloud_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.cloud_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::PointCloud& Message::cloud() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.cloud)
  return has_cloud()
      ? *msg_.cloud_
      : *reinterpret_cast< ::itd::communication::protobuf::PointCloud*>(&::itd::communication::protobuf::_PointCloud_default_instance_);
}
inline ::itd::communication::protobuf::PointCloud* Message::unsafe_arena_release_cloud() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.cloud)
  if (has_cloud()) {
    clear_has_msg();
    ::itd::communication::protobuf::PointCloud* temp = msg_.cloud_;
    msg_.cloud_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_cloud(::itd::communication::protobuf::PointCloud* cloud) {
  clear_msg();
  if (cloud) {
    set_has_cloud();
    msg_.cloud_ = cloud;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.cloud)
}
inline ::itd::communication::protobuf::PointCloud* Message::mutable_cloud() {
  if (!has_cloud()) {
    clear_msg();
    set_has_cloud();
    msg_.cloud_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::PointCloud >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.cloud)
  return msg_.cloud_;
}

// .itd.communication.protobuf.Freespace fs = 12;
inline bool Message::has_fs() const {
  return msg_case() == kFs;
}
inline void Message::set_has_fs() {
  _oneof_case_[0] = kFs;
}
inline void Message::clear_fs() {
  if (has_fs()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.fs_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Freespace* Message::release_fs() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.fs)
  if (has_fs()) {
    clear_has_msg();
      ::itd::communication::protobuf::Freespace* temp = msg_.fs_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.fs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Freespace& Message::fs() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.fs)
  return has_fs()
      ? *msg_.fs_
      : *reinterpret_cast< ::itd::communication::protobuf::Freespace*>(&::itd::communication::protobuf::_Freespace_default_instance_);
}
inline ::itd::communication::protobuf::Freespace* Message::unsafe_arena_release_fs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.fs)
  if (has_fs()) {
    clear_has_msg();
    ::itd::communication::protobuf::Freespace* temp = msg_.fs_;
    msg_.fs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_fs(::itd::communication::protobuf::Freespace* fs) {
  clear_msg();
  if (fs) {
    set_has_fs();
    msg_.fs_ = fs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.fs)
}
inline ::itd::communication::protobuf::Freespace* Message::mutable_fs() {
  if (!has_fs()) {
    clear_msg();
    set_has_fs();
    msg_.fs_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Freespace >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.fs)
  return msg_.fs_;
}

// .itd.communication.protobuf.Trailer trailer = 13;
inline bool Message::has_trailer() const {
  return msg_case() == kTrailer;
}
inline void Message::set_has_trailer() {
  _oneof_case_[0] = kTrailer;
}
inline void Message::clear_trailer() {
  if (has_trailer()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.trailer_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Trailer* Message::release_trailer() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.trailer)
  if (has_trailer()) {
    clear_has_msg();
      ::itd::communication::protobuf::Trailer* temp = msg_.trailer_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.trailer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Trailer& Message::trailer() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.trailer)
  return has_trailer()
      ? *msg_.trailer_
      : *reinterpret_cast< ::itd::communication::protobuf::Trailer*>(&::itd::communication::protobuf::_Trailer_default_instance_);
}
inline ::itd::communication::protobuf::Trailer* Message::unsafe_arena_release_trailer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.trailer)
  if (has_trailer()) {
    clear_has_msg();
    ::itd::communication::protobuf::Trailer* temp = msg_.trailer_;
    msg_.trailer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_trailer(::itd::communication::protobuf::Trailer* trailer) {
  clear_msg();
  if (trailer) {
    set_has_trailer();
    msg_.trailer_ = trailer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.trailer)
}
inline ::itd::communication::protobuf::Trailer* Message::mutable_trailer() {
  if (!has_trailer()) {
    clear_msg();
    set_has_trailer();
    msg_.trailer_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Trailer >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.trailer)
  return msg_.trailer_;
}

// .itd.communication.protobuf.Bridge bridge = 14;
inline bool Message::has_bridge() const {
  return msg_case() == kBridge;
}
inline void Message::set_has_bridge() {
  _oneof_case_[0] = kBridge;
}
inline void Message::clear_bridge() {
  if (has_bridge()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.bridge_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Bridge* Message::release_bridge() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.bridge)
  if (has_bridge()) {
    clear_has_msg();
      ::itd::communication::protobuf::Bridge* temp = msg_.bridge_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.bridge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Bridge& Message::bridge() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.bridge)
  return has_bridge()
      ? *msg_.bridge_
      : *reinterpret_cast< ::itd::communication::protobuf::Bridge*>(&::itd::communication::protobuf::_Bridge_default_instance_);
}
inline ::itd::communication::protobuf::Bridge* Message::unsafe_arena_release_bridge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.bridge)
  if (has_bridge()) {
    clear_has_msg();
    ::itd::communication::protobuf::Bridge* temp = msg_.bridge_;
    msg_.bridge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_bridge(::itd::communication::protobuf::Bridge* bridge) {
  clear_msg();
  if (bridge) {
    set_has_bridge();
    msg_.bridge_ = bridge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.bridge)
}
inline ::itd::communication::protobuf::Bridge* Message::mutable_bridge() {
  if (!has_bridge()) {
    clear_msg();
    set_has_bridge();
    msg_.bridge_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Bridge >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.bridge)
  return msg_.bridge_;
}

// .itd.communication.protobuf.Boundary boundary = 15;
inline bool Message::has_boundary() const {
  return msg_case() == kBoundary;
}
inline void Message::set_has_boundary() {
  _oneof_case_[0] = kBoundary;
}
inline void Message::clear_boundary() {
  if (has_boundary()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.boundary_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Boundary* Message::release_boundary() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.boundary)
  if (has_boundary()) {
    clear_has_msg();
      ::itd::communication::protobuf::Boundary* temp = msg_.boundary_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.boundary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Boundary& Message::boundary() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.boundary)
  return has_boundary()
      ? *msg_.boundary_
      : *reinterpret_cast< ::itd::communication::protobuf::Boundary*>(&::itd::communication::protobuf::_Boundary_default_instance_);
}
inline ::itd::communication::protobuf::Boundary* Message::unsafe_arena_release_boundary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.boundary)
  if (has_boundary()) {
    clear_has_msg();
    ::itd::communication::protobuf::Boundary* temp = msg_.boundary_;
    msg_.boundary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_boundary(::itd::communication::protobuf::Boundary* boundary) {
  clear_msg();
  if (boundary) {
    set_has_boundary();
    msg_.boundary_ = boundary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.boundary)
}
inline ::itd::communication::protobuf::Boundary* Message::mutable_boundary() {
  if (!has_boundary()) {
    clear_msg();
    set_has_boundary();
    msg_.boundary_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Boundary >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.boundary)
  return msg_.boundary_;
}

// .itd.communication.protobuf.Container container = 16;
inline bool Message::has_container() const {
  return msg_case() == kContainer;
}
inline void Message::set_has_container() {
  _oneof_case_[0] = kContainer;
}
inline void Message::clear_container() {
  if (has_container()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.container_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Container* Message::release_container() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.container)
  if (has_container()) {
    clear_has_msg();
      ::itd::communication::protobuf::Container* temp = msg_.container_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.container_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Container& Message::container() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.container)
  return has_container()
      ? *msg_.container_
      : *reinterpret_cast< ::itd::communication::protobuf::Container*>(&::itd::communication::protobuf::_Container_default_instance_);
}
inline ::itd::communication::protobuf::Container* Message::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.container)
  if (has_container()) {
    clear_has_msg();
    ::itd::communication::protobuf::Container* temp = msg_.container_;
    msg_.container_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_container(::itd::communication::protobuf::Container* container) {
  clear_msg();
  if (container) {
    set_has_container();
    msg_.container_ = container;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.container)
}
inline ::itd::communication::protobuf::Container* Message::mutable_container() {
  if (!has_container()) {
    clear_msg();
    set_has_container();
    msg_.container_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Container >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.container)
  return msg_.container_;
}

// .itd.communication.protobuf.Signboard signboard = 17;
inline bool Message::has_signboard() const {
  return msg_case() == kSignboard;
}
inline void Message::set_has_signboard() {
  _oneof_case_[0] = kSignboard;
}
inline void Message::clear_signboard() {
  if (has_signboard()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.signboard_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Signboard* Message::release_signboard() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.signboard)
  if (has_signboard()) {
    clear_has_msg();
      ::itd::communication::protobuf::Signboard* temp = msg_.signboard_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.signboard_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Signboard& Message::signboard() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.signboard)
  return has_signboard()
      ? *msg_.signboard_
      : *reinterpret_cast< ::itd::communication::protobuf::Signboard*>(&::itd::communication::protobuf::_Signboard_default_instance_);
}
inline ::itd::communication::protobuf::Signboard* Message::unsafe_arena_release_signboard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.signboard)
  if (has_signboard()) {
    clear_has_msg();
    ::itd::communication::protobuf::Signboard* temp = msg_.signboard_;
    msg_.signboard_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_signboard(::itd::communication::protobuf::Signboard* signboard) {
  clear_msg();
  if (signboard) {
    set_has_signboard();
    msg_.signboard_ = signboard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.signboard)
}
inline ::itd::communication::protobuf::Signboard* Message::mutable_signboard() {
  if (!has_signboard()) {
    clear_msg();
    set_has_signboard();
    msg_.signboard_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Signboard >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.signboard)
  return msg_.signboard_;
}

// .itd.communication.protobuf.LidarStatus lidar_status = 18;
inline bool Message::has_lidar_status() const {
  return msg_case() == kLidarStatus;
}
inline void Message::set_has_lidar_status() {
  _oneof_case_[0] = kLidarStatus;
}
inline void Message::clear_lidar_status() {
  if (has_lidar_status()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.lidar_status_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::LidarStatus* Message::release_lidar_status() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.lidar_status)
  if (has_lidar_status()) {
    clear_has_msg();
      ::itd::communication::protobuf::LidarStatus* temp = msg_.lidar_status_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.lidar_status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::LidarStatus& Message::lidar_status() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.lidar_status)
  return has_lidar_status()
      ? *msg_.lidar_status_
      : *reinterpret_cast< ::itd::communication::protobuf::LidarStatus*>(&::itd::communication::protobuf::_LidarStatus_default_instance_);
}
inline ::itd::communication::protobuf::LidarStatus* Message::unsafe_arena_release_lidar_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.lidar_status)
  if (has_lidar_status()) {
    clear_has_msg();
    ::itd::communication::protobuf::LidarStatus* temp = msg_.lidar_status_;
    msg_.lidar_status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_lidar_status(::itd::communication::protobuf::LidarStatus* lidar_status) {
  clear_msg();
  if (lidar_status) {
    set_has_lidar_status();
    msg_.lidar_status_ = lidar_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.lidar_status)
}
inline ::itd::communication::protobuf::LidarStatus* Message::mutable_lidar_status() {
  if (!has_lidar_status()) {
    clear_msg();
    set_has_lidar_status();
    msg_.lidar_status_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::LidarStatus >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.lidar_status)
  return msg_.lidar_status_;
}

// .itd.communication.protobuf.BoundingBox boundingBox = 19;
inline bool Message::has_boundingbox() const {
  return msg_case() == kBoundingBox;
}
inline void Message::set_has_boundingbox() {
  _oneof_case_[0] = kBoundingBox;
}
inline void Message::clear_boundingbox() {
  if (has_boundingbox()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.boundingbox_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::BoundingBox* Message::release_boundingbox() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.boundingBox)
  if (has_boundingbox()) {
    clear_has_msg();
      ::itd::communication::protobuf::BoundingBox* temp = msg_.boundingbox_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.boundingbox_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::BoundingBox& Message::boundingbox() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.boundingBox)
  return has_boundingbox()
      ? *msg_.boundingbox_
      : *reinterpret_cast< ::itd::communication::protobuf::BoundingBox*>(&::itd::communication::protobuf::_BoundingBox_default_instance_);
}
inline ::itd::communication::protobuf::BoundingBox* Message::unsafe_arena_release_boundingbox() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.boundingBox)
  if (has_boundingbox()) {
    clear_has_msg();
    ::itd::communication::protobuf::BoundingBox* temp = msg_.boundingbox_;
    msg_.boundingbox_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_boundingbox(::itd::communication::protobuf::BoundingBox* boundingbox) {
  clear_msg();
  if (boundingbox) {
    set_has_boundingbox();
    msg_.boundingbox_ = boundingbox;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.boundingBox)
}
inline ::itd::communication::protobuf::BoundingBox* Message::mutable_boundingbox() {
  if (!has_boundingbox()) {
    clear_msg();
    set_has_boundingbox();
    msg_.boundingbox_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::BoundingBox >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.boundingBox)
  return msg_.boundingbox_;
}

// .itd.communication.protobuf.CanSignal can_signal = 20;
inline bool Message::has_can_signal() const {
  return msg_case() == kCanSignal;
}
inline void Message::set_has_can_signal() {
  _oneof_case_[0] = kCanSignal;
}
inline void Message::clear_can_signal() {
  if (has_can_signal()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.can_signal_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::CanSignal* Message::release_can_signal() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Message.can_signal)
  if (has_can_signal()) {
    clear_has_msg();
      ::itd::communication::protobuf::CanSignal* temp = msg_.can_signal_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.can_signal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::CanSignal& Message::can_signal() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Message.can_signal)
  return has_can_signal()
      ? *msg_.can_signal_
      : *reinterpret_cast< ::itd::communication::protobuf::CanSignal*>(&::itd::communication::protobuf::_CanSignal_default_instance_);
}
inline ::itd::communication::protobuf::CanSignal* Message::unsafe_arena_release_can_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Message.can_signal)
  if (has_can_signal()) {
    clear_has_msg();
    ::itd::communication::protobuf::CanSignal* temp = msg_.can_signal_;
    msg_.can_signal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::unsafe_arena_set_allocated_can_signal(::itd::communication::protobuf::CanSignal* can_signal) {
  clear_msg();
  if (can_signal) {
    set_has_can_signal();
    msg_.can_signal_ = can_signal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.Message.can_signal)
}
inline ::itd::communication::protobuf::CanSignal* Message::mutable_can_signal() {
  if (!has_can_signal()) {
    clear_msg();
    set_has_can_signal();
    msg_.can_signal_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::CanSignal >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Message.can_signal)
  return msg_.can_signal_;
}

inline bool Message::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Message::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Message::MsgCase Message::msg_case() const {
  return Message::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace communication
}  // namespace itd

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::itd::communication::protobuf::Message_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::itd::communication::protobuf::Message_MessageType>() {
  return ::itd::communication::protobuf::Message_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
