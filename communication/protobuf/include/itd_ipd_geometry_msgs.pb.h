// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: itd_ipd_geometry_msgs.proto

#ifndef PROTOBUF_itd_5fipd_5fgeometry_5fmsgs_2eproto__INCLUDED
#define PROTOBUF_itd_5fipd_5fgeometry_5fmsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "itd_ipd_std_msgs.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsGeometryImpl();
void InitDefaultsGeometry();
void InitDefaultsPointImpl();
void InitDefaultsPoint();
void InitDefaultsPointsImpl();
void InitDefaultsPoints();
void InitDefaultsLineImpl();
void InitDefaultsLine();
void InitDefaultsLinesImpl();
void InitDefaultsLines();
void InitDefaultsPolygonImpl();
void InitDefaultsPolygon();
void InitDefaultsPolygonsImpl();
void InitDefaultsPolygons();
void InitDefaultsPoseImpl();
void InitDefaultsPose();
void InitDefaultsPosesImpl();
void InitDefaultsPoses();
void InitDefaultsMessageGeometryImpl();
void InitDefaultsMessageGeometry();
inline void InitDefaults() {
  InitDefaultsGeometry();
  InitDefaultsPoint();
  InitDefaultsPoints();
  InitDefaultsLine();
  InitDefaultsLines();
  InitDefaultsPolygon();
  InitDefaultsPolygons();
  InitDefaultsPose();
  InitDefaultsPoses();
  InitDefaultsMessageGeometry();
}
}  // namespace protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto
namespace itd {
namespace communication {
namespace protobuf {
class Geometry;
class GeometryDefaultTypeInternal;
extern GeometryDefaultTypeInternal _Geometry_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class Lines;
class LinesDefaultTypeInternal;
extern LinesDefaultTypeInternal _Lines_default_instance_;
class MessageGeometry;
class MessageGeometryDefaultTypeInternal;
extern MessageGeometryDefaultTypeInternal _MessageGeometry_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Points;
class PointsDefaultTypeInternal;
extern PointsDefaultTypeInternal _Points_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Polygons;
class PolygonsDefaultTypeInternal;
extern PolygonsDefaultTypeInternal _Polygons_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Poses;
class PosesDefaultTypeInternal;
extern PosesDefaultTypeInternal _Poses_default_instance_;
}  // namespace protobuf
}  // namespace communication
}  // namespace itd
namespace itd {
namespace communication {
namespace protobuf {

enum MessageGeometry_MessageType {
  MessageGeometry_MessageType_Point = 0,
  MessageGeometry_MessageType_Points = 1,
  MessageGeometry_MessageType_Line = 2,
  MessageGeometry_MessageType_Lines = 3,
  MessageGeometry_MessageType_Polygon = 4,
  MessageGeometry_MessageType_Polygons = 5,
  MessageGeometry_MessageType_Pose = 6,
  MessageGeometry_MessageType_Poses = 7,
  MessageGeometry_MessageType_MessageGeometry_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageGeometry_MessageType_MessageGeometry_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageGeometry_MessageType_IsValid(int value);
const MessageGeometry_MessageType MessageGeometry_MessageType_MessageType_MIN = MessageGeometry_MessageType_Point;
const MessageGeometry_MessageType MessageGeometry_MessageType_MessageType_MAX = MessageGeometry_MessageType_Poses;
const int MessageGeometry_MessageType_MessageType_ARRAYSIZE = MessageGeometry_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageGeometry_MessageType_descriptor();
inline const ::std::string& MessageGeometry_MessageType_Name(MessageGeometry_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageGeometry_MessageType_descriptor(), value);
}
inline bool MessageGeometry_MessageType_Parse(
    const ::std::string& name, MessageGeometry_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageGeometry_MessageType>(
    MessageGeometry_MessageType_descriptor(), name, value);
}
// ===================================================================

class Geometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Geometry) */ {
 public:
  Geometry();
  virtual ~Geometry();

  Geometry(const Geometry& from);

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geometry(Geometry&& from) noexcept
    : Geometry() {
    *this = ::std::move(from);
  }

  inline Geometry& operator=(Geometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geometry* internal_default_instance() {
    return reinterpret_cast<const Geometry*>(
               &_Geometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Geometry* other);
  void Swap(Geometry* other);
  friend void swap(Geometry& a, Geometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geometry* New() const PROTOBUF_FINAL { return New(NULL); }

  Geometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Geometry* other);
  protected:
  explicit Geometry(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float x = 2;
  int x_size() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::google::protobuf::RepeatedField< float >&
      x() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_x();

  // repeated float y = 3;
  int y_size() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::google::protobuf::RepeatedField< float >&
      y() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_y();

  // repeated float z = 4;
  int z_size() const;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z(int index) const;
  void set_z(int index, float value);
  void add_z(float value);
  const ::google::protobuf::RepeatedField< float >&
      z() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_z();

  // int32 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Geometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< float > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > y_;
  mutable int _y_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > z_;
  mutable int _z_cached_byte_size_;
  ::google::protobuf::int32 count_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsGeometryImpl();
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Point* other);
  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  protected:
  explicit Point(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // float y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // float z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsPointImpl();
};
// -------------------------------------------------------------------

class Points : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Points) */ {
 public:
  Points();
  virtual ~Points();

  Points(const Points& from);

  inline Points& operator=(const Points& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Points(Points&& from) noexcept
    : Points() {
    *this = ::std::move(from);
  }

  inline Points& operator=(Points&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Points& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Points* internal_default_instance() {
    return reinterpret_cast<const Points*>(
               &_Points_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Points* other);
  void Swap(Points* other);
  friend void swap(Points& a, Points& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Points* New() const PROTOBUF_FINAL { return New(NULL); }

  Points* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Points& from);
  void MergeFrom(const Points& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Points* other);
  protected:
  explicit Points(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // .itd.communication.protobuf.Geometry geometry = 2;
  bool has_geometry() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 2;
  private:
  void _slow_mutable_geometry();
  public:
  const ::itd::communication::protobuf::Geometry& geometry() const;
  ::itd::communication::protobuf::Geometry* release_geometry();
  ::itd::communication::protobuf::Geometry* mutable_geometry();
  void set_allocated_geometry(::itd::communication::protobuf::Geometry* geometry);
  void unsafe_arena_set_allocated_geometry(
      ::itd::communication::protobuf::Geometry* geometry);
  ::itd::communication::protobuf::Geometry* unsafe_arena_release_geometry();

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Points)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  ::itd::communication::protobuf::Geometry* geometry_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsPointsImpl();
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Line* other);
  void Swap(Line* other);
  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const PROTOBUF_FINAL { return New(NULL); }

  Line* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Line* other);
  protected:
  explicit Line(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // .itd.communication.protobuf.Geometry geometry = 2;
  bool has_geometry() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 2;
  private:
  void _slow_mutable_geometry();
  public:
  const ::itd::communication::protobuf::Geometry& geometry() const;
  ::itd::communication::protobuf::Geometry* release_geometry();
  ::itd::communication::protobuf::Geometry* mutable_geometry();
  void set_allocated_geometry(::itd::communication::protobuf::Geometry* geometry);
  void unsafe_arena_set_allocated_geometry(
      ::itd::communication::protobuf::Geometry* geometry);
  ::itd::communication::protobuf::Geometry* unsafe_arena_release_geometry();

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Line)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  ::itd::communication::protobuf::Geometry* geometry_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsLineImpl();
};
// -------------------------------------------------------------------

class Lines : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Lines) */ {
 public:
  Lines();
  virtual ~Lines();

  Lines(const Lines& from);

  inline Lines& operator=(const Lines& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lines(Lines&& from) noexcept
    : Lines() {
    *this = ::std::move(from);
  }

  inline Lines& operator=(Lines&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lines& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lines* internal_default_instance() {
    return reinterpret_cast<const Lines*>(
               &_Lines_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Lines* other);
  void Swap(Lines* other);
  friend void swap(Lines& a, Lines& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lines* New() const PROTOBUF_FINAL { return New(NULL); }

  Lines* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Lines& from);
  void MergeFrom(const Lines& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Lines* other);
  protected:
  explicit Lines(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .itd.communication.protobuf.Line line = 2;
  int line_size() const;
  void clear_line();
  static const int kLineFieldNumber = 2;
  const ::itd::communication::protobuf::Line& line(int index) const;
  ::itd::communication::protobuf::Line* mutable_line(int index);
  ::itd::communication::protobuf::Line* add_line();
  ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Line >*
      mutable_line();
  const ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Line >&
      line() const;

  // int32 number_lines = 1;
  void clear_number_lines();
  static const int kNumberLinesFieldNumber = 1;
  ::google::protobuf::int32 number_lines() const;
  void set_number_lines(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Lines)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Line > line_;
  ::google::protobuf::int32 number_lines_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsLinesImpl();
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(Polygon* other);
  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const PROTOBUF_FINAL { return New(NULL); }

  Polygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Polygon* other);
  protected:
  explicit Polygon(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // .itd.communication.protobuf.Geometry geometry = 2;
  bool has_geometry() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 2;
  private:
  void _slow_mutable_geometry();
  public:
  const ::itd::communication::protobuf::Geometry& geometry() const;
  ::itd::communication::protobuf::Geometry* release_geometry();
  ::itd::communication::protobuf::Geometry* mutable_geometry();
  void set_allocated_geometry(::itd::communication::protobuf::Geometry* geometry);
  void unsafe_arena_set_allocated_geometry(
      ::itd::communication::protobuf::Geometry* geometry);
  ::itd::communication::protobuf::Geometry* unsafe_arena_release_geometry();

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Polygon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  ::itd::communication::protobuf::Geometry* geometry_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsPolygonImpl();
};
// -------------------------------------------------------------------

class Polygons : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Polygons) */ {
 public:
  Polygons();
  virtual ~Polygons();

  Polygons(const Polygons& from);

  inline Polygons& operator=(const Polygons& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygons(Polygons&& from) noexcept
    : Polygons() {
    *this = ::std::move(from);
  }

  inline Polygons& operator=(Polygons&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygons& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygons* internal_default_instance() {
    return reinterpret_cast<const Polygons*>(
               &_Polygons_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(Polygons* other);
  void Swap(Polygons* other);
  friend void swap(Polygons& a, Polygons& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygons* New() const PROTOBUF_FINAL { return New(NULL); }

  Polygons* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Polygons& from);
  void MergeFrom(const Polygons& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Polygons* other);
  protected:
  explicit Polygons(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .itd.communication.protobuf.Polygon polygon = 3;
  int polygon_size() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 3;
  const ::itd::communication::protobuf::Polygon& polygon(int index) const;
  ::itd::communication::protobuf::Polygon* mutable_polygon(int index);
  ::itd::communication::protobuf::Polygon* add_polygon();
  ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Polygon >*
      mutable_polygon();
  const ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Polygon >&
      polygon() const;

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // int32 number_polygons = 2;
  void clear_number_polygons();
  static const int kNumberPolygonsFieldNumber = 2;
  ::google::protobuf::int32 number_polygons() const;
  void set_number_polygons(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Polygons)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Polygon > polygon_;
  ::itd::communication::protobuf::Header* header_;
  ::google::protobuf::int32 number_polygons_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsPolygonsImpl();
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(Pose* other);
  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose* other);
  protected:
  explicit Pose(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // float x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // float y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // float z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // float roll = 5;
  void clear_roll();
  static const int kRollFieldNumber = 5;
  float roll() const;
  void set_roll(float value);

  // float pitch = 6;
  void clear_pitch();
  static const int kPitchFieldNumber = 6;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 7;
  void clear_yaw();
  static const int kYawFieldNumber = 7;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::itd::communication::protobuf::Header* header_;
  float x_;
  float y_;
  float z_;
  float roll_;
  float pitch_;
  float yaw_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsPoseImpl();
};
// -------------------------------------------------------------------

class Poses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.Poses) */ {
 public:
  Poses();
  virtual ~Poses();

  Poses(const Poses& from);

  inline Poses& operator=(const Poses& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Poses(Poses&& from) noexcept
    : Poses() {
    *this = ::std::move(from);
  }

  inline Poses& operator=(Poses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Poses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Poses* internal_default_instance() {
    return reinterpret_cast<const Poses*>(
               &_Poses_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(Poses* other);
  void Swap(Poses* other);
  friend void swap(Poses& a, Poses& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Poses* New() const PROTOBUF_FINAL { return New(NULL); }

  Poses* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Poses& from);
  void MergeFrom(const Poses& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Poses* other);
  protected:
  explicit Poses(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .itd.communication.protobuf.Pose pose = 2;
  int pose_size() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  const ::itd::communication::protobuf::Pose& pose(int index) const;
  ::itd::communication::protobuf::Pose* mutable_pose(int index);
  ::itd::communication::protobuf::Pose* add_pose();
  ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Pose >*
      mutable_pose();
  const ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Pose >&
      pose() const;

  // .itd.communication.protobuf.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  void _slow_mutable_header();
  public:
  const ::itd::communication::protobuf::Header& header() const;
  ::itd::communication::protobuf::Header* release_header();
  ::itd::communication::protobuf::Header* mutable_header();
  void set_allocated_header(::itd::communication::protobuf::Header* header);
  void unsafe_arena_set_allocated_header(
      ::itd::communication::protobuf::Header* header);
  ::itd::communication::protobuf::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.Poses)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Pose > pose_;
  ::itd::communication::protobuf::Header* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsPosesImpl();
};
// -------------------------------------------------------------------

class MessageGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:itd.communication.protobuf.MessageGeometry) */ {
 public:
  MessageGeometry();
  virtual ~MessageGeometry();

  MessageGeometry(const MessageGeometry& from);

  inline MessageGeometry& operator=(const MessageGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageGeometry(MessageGeometry&& from) noexcept
    : MessageGeometry() {
    *this = ::std::move(from);
  }

  inline MessageGeometry& operator=(MessageGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageGeometry& default_instance();

  enum MsgCase {
    kPoint = 9,
    kPoints = 10,
    kLine = 11,
    kLines = 12,
    kPolygon = 13,
    kPolygons = 14,
    kPose = 15,
    kPoses = 16,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageGeometry* internal_default_instance() {
    return reinterpret_cast<const MessageGeometry*>(
               &_MessageGeometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(MessageGeometry* other);
  void Swap(MessageGeometry* other);
  friend void swap(MessageGeometry& a, MessageGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageGeometry* New() const PROTOBUF_FINAL { return New(NULL); }

  MessageGeometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MessageGeometry& from);
  void MergeFrom(const MessageGeometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MessageGeometry* other);
  protected:
  explicit MessageGeometry(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MessageGeometry_MessageType MessageType;
  static const MessageType Point =
    MessageGeometry_MessageType_Point;
  static const MessageType Points =
    MessageGeometry_MessageType_Points;
  static const MessageType Line =
    MessageGeometry_MessageType_Line;
  static const MessageType Lines =
    MessageGeometry_MessageType_Lines;
  static const MessageType Polygon =
    MessageGeometry_MessageType_Polygon;
  static const MessageType Polygons =
    MessageGeometry_MessageType_Polygons;
  static const MessageType Pose =
    MessageGeometry_MessageType_Pose;
  static const MessageType Poses =
    MessageGeometry_MessageType_Poses;
  static inline bool MessageType_IsValid(int value) {
    return MessageGeometry_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    MessageGeometry_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    MessageGeometry_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    MessageGeometry_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return MessageGeometry_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return MessageGeometry_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return MessageGeometry_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .itd.communication.protobuf.MessageGeometry.MessageType type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::itd::communication::protobuf::MessageGeometry_MessageType type() const;
  void set_type(::itd::communication::protobuf::MessageGeometry_MessageType value);

  // .itd.communication.protobuf.Point point = 9;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 9;
  private:
  void _slow_mutable_point();
  public:
  const ::itd::communication::protobuf::Point& point() const;
  ::itd::communication::protobuf::Point* release_point();
  ::itd::communication::protobuf::Point* mutable_point();
  void set_allocated_point(::itd::communication::protobuf::Point* point);
  void unsafe_arena_set_allocated_point(
      ::itd::communication::protobuf::Point* point);
  ::itd::communication::protobuf::Point* unsafe_arena_release_point();

  // .itd.communication.protobuf.Points points = 10;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 10;
  private:
  void _slow_mutable_points();
  public:
  const ::itd::communication::protobuf::Points& points() const;
  ::itd::communication::protobuf::Points* release_points();
  ::itd::communication::protobuf::Points* mutable_points();
  void set_allocated_points(::itd::communication::protobuf::Points* points);
  void unsafe_arena_set_allocated_points(
      ::itd::communication::protobuf::Points* points);
  ::itd::communication::protobuf::Points* unsafe_arena_release_points();

  // .itd.communication.protobuf.Line line = 11;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 11;
  private:
  void _slow_mutable_line();
  public:
  const ::itd::communication::protobuf::Line& line() const;
  ::itd::communication::protobuf::Line* release_line();
  ::itd::communication::protobuf::Line* mutable_line();
  void set_allocated_line(::itd::communication::protobuf::Line* line);
  void unsafe_arena_set_allocated_line(
      ::itd::communication::protobuf::Line* line);
  ::itd::communication::protobuf::Line* unsafe_arena_release_line();

  // .itd.communication.protobuf.Lines lines = 12;
  bool has_lines() const;
  void clear_lines();
  static const int kLinesFieldNumber = 12;
  private:
  void _slow_mutable_lines();
  public:
  const ::itd::communication::protobuf::Lines& lines() const;
  ::itd::communication::protobuf::Lines* release_lines();
  ::itd::communication::protobuf::Lines* mutable_lines();
  void set_allocated_lines(::itd::communication::protobuf::Lines* lines);
  void unsafe_arena_set_allocated_lines(
      ::itd::communication::protobuf::Lines* lines);
  ::itd::communication::protobuf::Lines* unsafe_arena_release_lines();

  // .itd.communication.protobuf.Polygon polygon = 13;
  bool has_polygon() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 13;
  private:
  void _slow_mutable_polygon();
  public:
  const ::itd::communication::protobuf::Polygon& polygon() const;
  ::itd::communication::protobuf::Polygon* release_polygon();
  ::itd::communication::protobuf::Polygon* mutable_polygon();
  void set_allocated_polygon(::itd::communication::protobuf::Polygon* polygon);
  void unsafe_arena_set_allocated_polygon(
      ::itd::communication::protobuf::Polygon* polygon);
  ::itd::communication::protobuf::Polygon* unsafe_arena_release_polygon();

  // .itd.communication.protobuf.Polygons polygons = 14;
  bool has_polygons() const;
  void clear_polygons();
  static const int kPolygonsFieldNumber = 14;
  private:
  void _slow_mutable_polygons();
  public:
  const ::itd::communication::protobuf::Polygons& polygons() const;
  ::itd::communication::protobuf::Polygons* release_polygons();
  ::itd::communication::protobuf::Polygons* mutable_polygons();
  void set_allocated_polygons(::itd::communication::protobuf::Polygons* polygons);
  void unsafe_arena_set_allocated_polygons(
      ::itd::communication::protobuf::Polygons* polygons);
  ::itd::communication::protobuf::Polygons* unsafe_arena_release_polygons();

  // .itd.communication.protobuf.Pose pose = 15;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 15;
  private:
  void _slow_mutable_pose();
  public:
  const ::itd::communication::protobuf::Pose& pose() const;
  ::itd::communication::protobuf::Pose* release_pose();
  ::itd::communication::protobuf::Pose* mutable_pose();
  void set_allocated_pose(::itd::communication::protobuf::Pose* pose);
  void unsafe_arena_set_allocated_pose(
      ::itd::communication::protobuf::Pose* pose);
  ::itd::communication::protobuf::Pose* unsafe_arena_release_pose();

  // .itd.communication.protobuf.Poses poses = 16;
  bool has_poses() const;
  void clear_poses();
  static const int kPosesFieldNumber = 16;
  private:
  void _slow_mutable_poses();
  public:
  const ::itd::communication::protobuf::Poses& poses() const;
  ::itd::communication::protobuf::Poses* release_poses();
  ::itd::communication::protobuf::Poses* mutable_poses();
  void set_allocated_poses(::itd::communication::protobuf::Poses* poses);
  void unsafe_arena_set_allocated_poses(
      ::itd::communication::protobuf::Poses* poses);
  ::itd::communication::protobuf::Poses* unsafe_arena_release_poses();

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:itd.communication.protobuf.MessageGeometry)
 private:
  void set_has_point();
  void set_has_points();
  void set_has_line();
  void set_has_lines();
  void set_has_polygon();
  void set_has_polygons();
  void set_has_pose();
  void set_has_poses();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  union MsgUnion {
    MsgUnion() {}
    ::itd::communication::protobuf::Point* point_;
    ::itd::communication::protobuf::Points* points_;
    ::itd::communication::protobuf::Line* line_;
    ::itd::communication::protobuf::Lines* lines_;
    ::itd::communication::protobuf::Polygon* polygon_;
    ::itd::communication::protobuf::Polygons* polygons_;
    ::itd::communication::protobuf::Pose* pose_;
    ::itd::communication::protobuf::Poses* poses_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::TableStruct;
  friend void ::protobuf_itd_5fipd_5fgeometry_5fmsgs_2eproto::InitDefaultsMessageGeometryImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Geometry

// int32 count = 1;
inline void Geometry::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 Geometry::count() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Geometry.count)
  return count_;
}
inline void Geometry::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Geometry.count)
}

// repeated float x = 2;
inline int Geometry::x_size() const {
  return x_.size();
}
inline void Geometry::clear_x() {
  x_.Clear();
}
inline float Geometry::x(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Geometry.x)
  return x_.Get(index);
}
inline void Geometry::set_x(int index, float value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Geometry.x)
}
inline void Geometry::add_x(float value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Geometry.x)
}
inline const ::google::protobuf::RepeatedField< float >&
Geometry::x() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Geometry.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< float >*
Geometry::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Geometry.x)
  return &x_;
}

// repeated float y = 3;
inline int Geometry::y_size() const {
  return y_.size();
}
inline void Geometry::clear_y() {
  y_.Clear();
}
inline float Geometry::y(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Geometry.y)
  return y_.Get(index);
}
inline void Geometry::set_y(int index, float value) {
  y_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Geometry.y)
}
inline void Geometry::add_y(float value) {
  y_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Geometry.y)
}
inline const ::google::protobuf::RepeatedField< float >&
Geometry::y() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Geometry.y)
  return y_;
}
inline ::google::protobuf::RepeatedField< float >*
Geometry::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Geometry.y)
  return &y_;
}

// repeated float z = 4;
inline int Geometry::z_size() const {
  return z_.size();
}
inline void Geometry::clear_z() {
  z_.Clear();
}
inline float Geometry::z(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Geometry.z)
  return z_.Get(index);
}
inline void Geometry::set_z(int index, float value) {
  z_.Set(index, value);
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Geometry.z)
}
inline void Geometry::add_z(float value) {
  z_.Add(value);
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Geometry.z)
}
inline const ::google::protobuf::RepeatedField< float >&
Geometry::z() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Geometry.z)
  return z_;
}
inline ::google::protobuf::RepeatedField< float >*
Geometry::mutable_z() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Geometry.z)
  return &z_;
}

// -------------------------------------------------------------------

// Point

// .itd.communication.protobuf.Header header = 1;
inline bool Point::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Point::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Point.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Point::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Point.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Point::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Point.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Point::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Point.header)
  return header_;
}
inline void Point::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Point.header)
}

// float x = 2;
inline void Point::clear_x() {
  x_ = 0;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Point.x)
}

// float y = 3;
inline void Point::clear_y() {
  y_ = 0;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Point.y)
}

// float z = 4;
inline void Point::clear_z() {
  z_ = 0;
}
inline float Point::z() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Point.z)
  return z_;
}
inline void Point::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Point.z)
}

// -------------------------------------------------------------------

// Points

// .itd.communication.protobuf.Header header = 1;
inline bool Points::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Points::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Points.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Points::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Points.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Points::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Points.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Points::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Points.header)
  return header_;
}
inline void Points::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Points.header)
}

// .itd.communication.protobuf.Geometry geometry = 2;
inline bool Points::has_geometry() const {
  return this != internal_default_instance() && geometry_ != NULL;
}
inline void Points::clear_geometry() {
  if (GetArenaNoVirtual() == NULL && geometry_ != NULL) {
    delete geometry_;
  }
  geometry_ = NULL;
}
inline const ::itd::communication::protobuf::Geometry& Points::geometry() const {
  const ::itd::communication::protobuf::Geometry* p = geometry_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Points.geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Geometry*>(
      &::itd::communication::protobuf::_Geometry_default_instance_);
}
inline ::itd::communication::protobuf::Geometry* Points::release_geometry() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Points.geometry)
  
  ::itd::communication::protobuf::Geometry* temp = geometry_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  geometry_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Geometry* Points::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Points.geometry)
  
  ::itd::communication::protobuf::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Geometry* Points::mutable_geometry() {
  
  if (geometry_ == NULL) {
    _slow_mutable_geometry();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Points.geometry)
  return geometry_;
}
inline void Points::set_allocated_geometry(::itd::communication::protobuf::Geometry* geometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geometry_;
  }
  if (geometry) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Points.geometry)
}

// -------------------------------------------------------------------

// Line

// .itd.communication.protobuf.Header header = 1;
inline bool Line::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Line::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Line.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Line::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Line.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Line::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Line.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Line::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Line.header)
  return header_;
}
inline void Line::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Line.header)
}

// .itd.communication.protobuf.Geometry geometry = 2;
inline bool Line::has_geometry() const {
  return this != internal_default_instance() && geometry_ != NULL;
}
inline void Line::clear_geometry() {
  if (GetArenaNoVirtual() == NULL && geometry_ != NULL) {
    delete geometry_;
  }
  geometry_ = NULL;
}
inline const ::itd::communication::protobuf::Geometry& Line::geometry() const {
  const ::itd::communication::protobuf::Geometry* p = geometry_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Line.geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Geometry*>(
      &::itd::communication::protobuf::_Geometry_default_instance_);
}
inline ::itd::communication::protobuf::Geometry* Line::release_geometry() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Line.geometry)
  
  ::itd::communication::protobuf::Geometry* temp = geometry_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  geometry_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Geometry* Line::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Line.geometry)
  
  ::itd::communication::protobuf::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Geometry* Line::mutable_geometry() {
  
  if (geometry_ == NULL) {
    _slow_mutable_geometry();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Line.geometry)
  return geometry_;
}
inline void Line::set_allocated_geometry(::itd::communication::protobuf::Geometry* geometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geometry_;
  }
  if (geometry) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Line.geometry)
}

// -------------------------------------------------------------------

// Lines

// int32 number_lines = 1;
inline void Lines::clear_number_lines() {
  number_lines_ = 0;
}
inline ::google::protobuf::int32 Lines::number_lines() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Lines.number_lines)
  return number_lines_;
}
inline void Lines::set_number_lines(::google::protobuf::int32 value) {
  
  number_lines_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Lines.number_lines)
}

// repeated .itd.communication.protobuf.Line line = 2;
inline int Lines::line_size() const {
  return line_.size();
}
inline void Lines::clear_line() {
  line_.Clear();
}
inline const ::itd::communication::protobuf::Line& Lines::line(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Lines.line)
  return line_.Get(index);
}
inline ::itd::communication::protobuf::Line* Lines::mutable_line(int index) {
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Lines.line)
  return line_.Mutable(index);
}
inline ::itd::communication::protobuf::Line* Lines::add_line() {
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Lines.line)
  return line_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Line >*
Lines::mutable_line() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Lines.line)
  return &line_;
}
inline const ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Line >&
Lines::line() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Lines.line)
  return line_;
}

// -------------------------------------------------------------------

// Polygon

// .itd.communication.protobuf.Header header = 1;
inline bool Polygon::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Polygon::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Polygon.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Polygon::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Polygon.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Polygon::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Polygon.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Polygon::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Polygon.header)
  return header_;
}
inline void Polygon::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Polygon.header)
}

// .itd.communication.protobuf.Geometry geometry = 2;
inline bool Polygon::has_geometry() const {
  return this != internal_default_instance() && geometry_ != NULL;
}
inline void Polygon::clear_geometry() {
  if (GetArenaNoVirtual() == NULL && geometry_ != NULL) {
    delete geometry_;
  }
  geometry_ = NULL;
}
inline const ::itd::communication::protobuf::Geometry& Polygon::geometry() const {
  const ::itd::communication::protobuf::Geometry* p = geometry_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Polygon.geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Geometry*>(
      &::itd::communication::protobuf::_Geometry_default_instance_);
}
inline ::itd::communication::protobuf::Geometry* Polygon::release_geometry() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Polygon.geometry)
  
  ::itd::communication::protobuf::Geometry* temp = geometry_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  geometry_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Geometry* Polygon::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Polygon.geometry)
  
  ::itd::communication::protobuf::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Geometry* Polygon::mutable_geometry() {
  
  if (geometry_ == NULL) {
    _slow_mutable_geometry();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Polygon.geometry)
  return geometry_;
}
inline void Polygon::set_allocated_geometry(::itd::communication::protobuf::Geometry* geometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geometry_;
  }
  if (geometry) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Polygon.geometry)
}

// -------------------------------------------------------------------

// Polygons

// .itd.communication.protobuf.Header header = 1;
inline bool Polygons::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Polygons::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Polygons.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Polygons::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Polygons.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Polygons::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Polygons.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Polygons::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Polygons.header)
  return header_;
}
inline void Polygons::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Polygons.header)
}

// int32 number_polygons = 2;
inline void Polygons::clear_number_polygons() {
  number_polygons_ = 0;
}
inline ::google::protobuf::int32 Polygons::number_polygons() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Polygons.number_polygons)
  return number_polygons_;
}
inline void Polygons::set_number_polygons(::google::protobuf::int32 value) {
  
  number_polygons_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Polygons.number_polygons)
}

// repeated .itd.communication.protobuf.Polygon polygon = 3;
inline int Polygons::polygon_size() const {
  return polygon_.size();
}
inline void Polygons::clear_polygon() {
  polygon_.Clear();
}
inline const ::itd::communication::protobuf::Polygon& Polygons::polygon(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Polygons.polygon)
  return polygon_.Get(index);
}
inline ::itd::communication::protobuf::Polygon* Polygons::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Polygons.polygon)
  return polygon_.Mutable(index);
}
inline ::itd::communication::protobuf::Polygon* Polygons::add_polygon() {
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Polygons.polygon)
  return polygon_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Polygon >*
Polygons::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Polygons.polygon)
  return &polygon_;
}
inline const ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Polygon >&
Polygons::polygon() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Polygons.polygon)
  return polygon_;
}

// -------------------------------------------------------------------

// Pose

// .itd.communication.protobuf.Header header = 1;
inline bool Pose::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Pose::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Pose::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Pose.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Pose::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Pose.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Pose::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Pose.header)
  return header_;
}
inline void Pose::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Pose.header)
}

// float x = 2;
inline void Pose::clear_x() {
  x_ = 0;
}
inline float Pose::x() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.x)
  return x_;
}
inline void Pose::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Pose.x)
}

// float y = 3;
inline void Pose::clear_y() {
  y_ = 0;
}
inline float Pose::y() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.y)
  return y_;
}
inline void Pose::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Pose.y)
}

// float z = 4;
inline void Pose::clear_z() {
  z_ = 0;
}
inline float Pose::z() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.z)
  return z_;
}
inline void Pose::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Pose.z)
}

// float roll = 5;
inline void Pose::clear_roll() {
  roll_ = 0;
}
inline float Pose::roll() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.roll)
  return roll_;
}
inline void Pose::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Pose.roll)
}

// float pitch = 6;
inline void Pose::clear_pitch() {
  pitch_ = 0;
}
inline float Pose::pitch() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.pitch)
  return pitch_;
}
inline void Pose::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Pose.pitch)
}

// float yaw = 7;
inline void Pose::clear_yaw() {
  yaw_ = 0;
}
inline float Pose::yaw() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Pose.yaw)
  return yaw_;
}
inline void Pose::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.Pose.yaw)
}

// -------------------------------------------------------------------

// Poses

// .itd.communication.protobuf.Header header = 1;
inline bool Poses::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::itd::communication::protobuf::Header& Poses::header() const {
  const ::itd::communication::protobuf::Header* p = header_;
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Poses.header)
  return p != NULL ? *p : *reinterpret_cast<const ::itd::communication::protobuf::Header*>(
      &::itd::communication::protobuf::_Header_default_instance_);
}
inline ::itd::communication::protobuf::Header* Poses::release_header() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.Poses.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Poses::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.Poses.header)
  
  ::itd::communication::protobuf::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::itd::communication::protobuf::Header* Poses::mutable_header() {
  
  if (header_ == NULL) {
    _slow_mutable_header();
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Poses.header)
  return header_;
}
inline void Poses::set_allocated_header(::itd::communication::protobuf::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:itd.communication.protobuf.Poses.header)
}

// repeated .itd.communication.protobuf.Pose pose = 2;
inline int Poses::pose_size() const {
  return pose_.size();
}
inline void Poses::clear_pose() {
  pose_.Clear();
}
inline const ::itd::communication::protobuf::Pose& Poses::pose(int index) const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.Poses.pose)
  return pose_.Get(index);
}
inline ::itd::communication::protobuf::Pose* Poses::mutable_pose(int index) {
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.Poses.pose)
  return pose_.Mutable(index);
}
inline ::itd::communication::protobuf::Pose* Poses::add_pose() {
  // @@protoc_insertion_point(field_add:itd.communication.protobuf.Poses.pose)
  return pose_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Pose >*
Poses::mutable_pose() {
  // @@protoc_insertion_point(field_mutable_list:itd.communication.protobuf.Poses.pose)
  return &pose_;
}
inline const ::google::protobuf::RepeatedPtrField< ::itd::communication::protobuf::Pose >&
Poses::pose() const {
  // @@protoc_insertion_point(field_list:itd.communication.protobuf.Poses.pose)
  return pose_;
}

// -------------------------------------------------------------------

// MessageGeometry

// .itd.communication.protobuf.MessageGeometry.MessageType type = 8;
inline void MessageGeometry::clear_type() {
  type_ = 0;
}
inline ::itd::communication::protobuf::MessageGeometry_MessageType MessageGeometry::type() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.type)
  return static_cast< ::itd::communication::protobuf::MessageGeometry_MessageType >(type_);
}
inline void MessageGeometry::set_type(::itd::communication::protobuf::MessageGeometry_MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:itd.communication.protobuf.MessageGeometry.type)
}

// .itd.communication.protobuf.Point point = 9;
inline bool MessageGeometry::has_point() const {
  return msg_case() == kPoint;
}
inline void MessageGeometry::set_has_point() {
  _oneof_case_[0] = kPoint;
}
inline void MessageGeometry::clear_point() {
  if (has_point()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.point_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Point* MessageGeometry::release_point() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.point)
  if (has_point()) {
    clear_has_msg();
      ::itd::communication::protobuf::Point* temp = msg_.point_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Point& MessageGeometry::point() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.point)
  return has_point()
      ? *msg_.point_
      : *reinterpret_cast< ::itd::communication::protobuf::Point*>(&::itd::communication::protobuf::_Point_default_instance_);
}
inline ::itd::communication::protobuf::Point* MessageGeometry::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.point)
  if (has_point()) {
    clear_has_msg();
    ::itd::communication::protobuf::Point* temp = msg_.point_;
    msg_.point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_point(::itd::communication::protobuf::Point* point) {
  clear_msg();
  if (point) {
    set_has_point();
    msg_.point_ = point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.point)
}
inline ::itd::communication::protobuf::Point* MessageGeometry::mutable_point() {
  if (!has_point()) {
    clear_msg();
    set_has_point();
    msg_.point_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Point >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.point)
  return msg_.point_;
}

// .itd.communication.protobuf.Points points = 10;
inline bool MessageGeometry::has_points() const {
  return msg_case() == kPoints;
}
inline void MessageGeometry::set_has_points() {
  _oneof_case_[0] = kPoints;
}
inline void MessageGeometry::clear_points() {
  if (has_points()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.points_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Points* MessageGeometry::release_points() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.points)
  if (has_points()) {
    clear_has_msg();
      ::itd::communication::protobuf::Points* temp = msg_.points_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.points_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Points& MessageGeometry::points() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.points)
  return has_points()
      ? *msg_.points_
      : *reinterpret_cast< ::itd::communication::protobuf::Points*>(&::itd::communication::protobuf::_Points_default_instance_);
}
inline ::itd::communication::protobuf::Points* MessageGeometry::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.points)
  if (has_points()) {
    clear_has_msg();
    ::itd::communication::protobuf::Points* temp = msg_.points_;
    msg_.points_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_points(::itd::communication::protobuf::Points* points) {
  clear_msg();
  if (points) {
    set_has_points();
    msg_.points_ = points;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.points)
}
inline ::itd::communication::protobuf::Points* MessageGeometry::mutable_points() {
  if (!has_points()) {
    clear_msg();
    set_has_points();
    msg_.points_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Points >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.points)
  return msg_.points_;
}

// .itd.communication.protobuf.Line line = 11;
inline bool MessageGeometry::has_line() const {
  return msg_case() == kLine;
}
inline void MessageGeometry::set_has_line() {
  _oneof_case_[0] = kLine;
}
inline void MessageGeometry::clear_line() {
  if (has_line()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.line_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Line* MessageGeometry::release_line() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.line)
  if (has_line()) {
    clear_has_msg();
      ::itd::communication::protobuf::Line* temp = msg_.line_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.line_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Line& MessageGeometry::line() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.line)
  return has_line()
      ? *msg_.line_
      : *reinterpret_cast< ::itd::communication::protobuf::Line*>(&::itd::communication::protobuf::_Line_default_instance_);
}
inline ::itd::communication::protobuf::Line* MessageGeometry::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.line)
  if (has_line()) {
    clear_has_msg();
    ::itd::communication::protobuf::Line* temp = msg_.line_;
    msg_.line_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_line(::itd::communication::protobuf::Line* line) {
  clear_msg();
  if (line) {
    set_has_line();
    msg_.line_ = line;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.line)
}
inline ::itd::communication::protobuf::Line* MessageGeometry::mutable_line() {
  if (!has_line()) {
    clear_msg();
    set_has_line();
    msg_.line_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Line >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.line)
  return msg_.line_;
}

// .itd.communication.protobuf.Lines lines = 12;
inline bool MessageGeometry::has_lines() const {
  return msg_case() == kLines;
}
inline void MessageGeometry::set_has_lines() {
  _oneof_case_[0] = kLines;
}
inline void MessageGeometry::clear_lines() {
  if (has_lines()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.lines_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Lines* MessageGeometry::release_lines() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.lines)
  if (has_lines()) {
    clear_has_msg();
      ::itd::communication::protobuf::Lines* temp = msg_.lines_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.lines_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Lines& MessageGeometry::lines() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.lines)
  return has_lines()
      ? *msg_.lines_
      : *reinterpret_cast< ::itd::communication::protobuf::Lines*>(&::itd::communication::protobuf::_Lines_default_instance_);
}
inline ::itd::communication::protobuf::Lines* MessageGeometry::unsafe_arena_release_lines() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.lines)
  if (has_lines()) {
    clear_has_msg();
    ::itd::communication::protobuf::Lines* temp = msg_.lines_;
    msg_.lines_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_lines(::itd::communication::protobuf::Lines* lines) {
  clear_msg();
  if (lines) {
    set_has_lines();
    msg_.lines_ = lines;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.lines)
}
inline ::itd::communication::protobuf::Lines* MessageGeometry::mutable_lines() {
  if (!has_lines()) {
    clear_msg();
    set_has_lines();
    msg_.lines_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Lines >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.lines)
  return msg_.lines_;
}

// .itd.communication.protobuf.Polygon polygon = 13;
inline bool MessageGeometry::has_polygon() const {
  return msg_case() == kPolygon;
}
inline void MessageGeometry::set_has_polygon() {
  _oneof_case_[0] = kPolygon;
}
inline void MessageGeometry::clear_polygon() {
  if (has_polygon()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.polygon_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Polygon* MessageGeometry::release_polygon() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.polygon)
  if (has_polygon()) {
    clear_has_msg();
      ::itd::communication::protobuf::Polygon* temp = msg_.polygon_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.polygon_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Polygon& MessageGeometry::polygon() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.polygon)
  return has_polygon()
      ? *msg_.polygon_
      : *reinterpret_cast< ::itd::communication::protobuf::Polygon*>(&::itd::communication::protobuf::_Polygon_default_instance_);
}
inline ::itd::communication::protobuf::Polygon* MessageGeometry::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.polygon)
  if (has_polygon()) {
    clear_has_msg();
    ::itd::communication::protobuf::Polygon* temp = msg_.polygon_;
    msg_.polygon_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_polygon(::itd::communication::protobuf::Polygon* polygon) {
  clear_msg();
  if (polygon) {
    set_has_polygon();
    msg_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.polygon)
}
inline ::itd::communication::protobuf::Polygon* MessageGeometry::mutable_polygon() {
  if (!has_polygon()) {
    clear_msg();
    set_has_polygon();
    msg_.polygon_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Polygon >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.polygon)
  return msg_.polygon_;
}

// .itd.communication.protobuf.Polygons polygons = 14;
inline bool MessageGeometry::has_polygons() const {
  return msg_case() == kPolygons;
}
inline void MessageGeometry::set_has_polygons() {
  _oneof_case_[0] = kPolygons;
}
inline void MessageGeometry::clear_polygons() {
  if (has_polygons()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.polygons_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Polygons* MessageGeometry::release_polygons() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.polygons)
  if (has_polygons()) {
    clear_has_msg();
      ::itd::communication::protobuf::Polygons* temp = msg_.polygons_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.polygons_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Polygons& MessageGeometry::polygons() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.polygons)
  return has_polygons()
      ? *msg_.polygons_
      : *reinterpret_cast< ::itd::communication::protobuf::Polygons*>(&::itd::communication::protobuf::_Polygons_default_instance_);
}
inline ::itd::communication::protobuf::Polygons* MessageGeometry::unsafe_arena_release_polygons() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.polygons)
  if (has_polygons()) {
    clear_has_msg();
    ::itd::communication::protobuf::Polygons* temp = msg_.polygons_;
    msg_.polygons_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_polygons(::itd::communication::protobuf::Polygons* polygons) {
  clear_msg();
  if (polygons) {
    set_has_polygons();
    msg_.polygons_ = polygons;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.polygons)
}
inline ::itd::communication::protobuf::Polygons* MessageGeometry::mutable_polygons() {
  if (!has_polygons()) {
    clear_msg();
    set_has_polygons();
    msg_.polygons_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Polygons >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.polygons)
  return msg_.polygons_;
}

// .itd.communication.protobuf.Pose pose = 15;
inline bool MessageGeometry::has_pose() const {
  return msg_case() == kPose;
}
inline void MessageGeometry::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline void MessageGeometry::clear_pose() {
  if (has_pose()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.pose_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Pose* MessageGeometry::release_pose() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.pose)
  if (has_pose()) {
    clear_has_msg();
      ::itd::communication::protobuf::Pose* temp = msg_.pose_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Pose& MessageGeometry::pose() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.pose)
  return has_pose()
      ? *msg_.pose_
      : *reinterpret_cast< ::itd::communication::protobuf::Pose*>(&::itd::communication::protobuf::_Pose_default_instance_);
}
inline ::itd::communication::protobuf::Pose* MessageGeometry::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.pose)
  if (has_pose()) {
    clear_has_msg();
    ::itd::communication::protobuf::Pose* temp = msg_.pose_;
    msg_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_pose(::itd::communication::protobuf::Pose* pose) {
  clear_msg();
  if (pose) {
    set_has_pose();
    msg_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.pose)
}
inline ::itd::communication::protobuf::Pose* MessageGeometry::mutable_pose() {
  if (!has_pose()) {
    clear_msg();
    set_has_pose();
    msg_.pose_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Pose >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.pose)
  return msg_.pose_;
}

// .itd.communication.protobuf.Poses poses = 16;
inline bool MessageGeometry::has_poses() const {
  return msg_case() == kPoses;
}
inline void MessageGeometry::set_has_poses() {
  _oneof_case_[0] = kPoses;
}
inline void MessageGeometry::clear_poses() {
  if (has_poses()) {
    if (GetArenaNoVirtual() == NULL) {
      delete msg_.poses_;
    }
    clear_has_msg();
  }
}
inline ::itd::communication::protobuf::Poses* MessageGeometry::release_poses() {
  // @@protoc_insertion_point(field_release:itd.communication.protobuf.MessageGeometry.poses)
  if (has_poses()) {
    clear_has_msg();
      ::itd::communication::protobuf::Poses* temp = msg_.poses_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
    }
    msg_.poses_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::itd::communication::protobuf::Poses& MessageGeometry::poses() const {
  // @@protoc_insertion_point(field_get:itd.communication.protobuf.MessageGeometry.poses)
  return has_poses()
      ? *msg_.poses_
      : *reinterpret_cast< ::itd::communication::protobuf::Poses*>(&::itd::communication::protobuf::_Poses_default_instance_);
}
inline ::itd::communication::protobuf::Poses* MessageGeometry::unsafe_arena_release_poses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:itd.communication.protobuf.MessageGeometry.poses)
  if (has_poses()) {
    clear_has_msg();
    ::itd::communication::protobuf::Poses* temp = msg_.poses_;
    msg_.poses_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageGeometry::unsafe_arena_set_allocated_poses(::itd::communication::protobuf::Poses* poses) {
  clear_msg();
  if (poses) {
    set_has_poses();
    msg_.poses_ = poses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:itd.communication.protobuf.MessageGeometry.poses)
}
inline ::itd::communication::protobuf::Poses* MessageGeometry::mutable_poses() {
  if (!has_poses()) {
    clear_msg();
    set_has_poses();
    msg_.poses_ = 
      ::google::protobuf::Arena::CreateMessage< ::itd::communication::protobuf::Poses >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:itd.communication.protobuf.MessageGeometry.poses)
  return msg_.poses_;
}

inline bool MessageGeometry::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void MessageGeometry::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline MessageGeometry::MsgCase MessageGeometry::msg_case() const {
  return MessageGeometry::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace communication
}  // namespace itd

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::itd::communication::protobuf::MessageGeometry_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::itd::communication::protobuf::MessageGeometry_MessageType>() {
  return ::itd::communication::protobuf::MessageGeometry_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_itd_5fipd_5fgeometry_5fmsgs_2eproto__INCLUDED
